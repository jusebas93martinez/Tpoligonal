{"version":3,"sources":["components/GraficoPoligonalSVG.js","components/FormularioObservacion.js","App.js","reportWebVitals.js","index.js"],"names":["GraficoPoligonal","_ref","observacionesCompensadas","colorLinea","setColorLinea","useState","grosorLinea","setGrosorLinea","colorPunto","setColorPunto","tamañoFlecha","setTamañoFlecha","colorFlecha","setColorFlecha","mostrarFlecha","setMostrarFlecha","mostrarMenu","setMostrarMenu","minX","Math","min","map","p","parseFloat","nuevoEsteAjustado","maxX","max","minY","nuevoNorteAjustado","maxY","rangoX","rangoY","React","createElement","style","position","border","width","height","padding","onClick","top","right","zIndex","left","backgroundColor","borderRadius","boxShadow","fontSize","display","marginBottom","type","value","onChange","e","target","marginTop","Number","checked","UncontrolledReactSVGPanZoom","background","tool","detectAutoPan","toolbarProps","FormularioObservacion","agregarObservacion","norteInicial","setNorteInicial","esteInicial","setEsteInicial","norteVisado","setNorteVisado","esteVisado","setEsteVisado","azimutInicial","setAzimutInicial","distanciaInicial","setDistanciaInicial","coordenadasCalculadas","setCoordenadasCalculadas","gradosH","setGradosH","minutosH","setMinutosH","segundosH","setSegundosH","gradosV","setGradosV","minutosV","setMinutosV","segundosV","setSegundosV","distanciaObservada","setDistanciaObservada","alturaInicial","setAlturaInicial","nuevoAzimut","setNuevoAzimut","sumaTeorica","setSumaTeorica","sumaReal","setSumaReal","errorAngular","setErrorAngular","sentidoPoligonal","setSentidoPoligonal","setObservacionesCompensadas","brazoExterno","setBrazoExterno","cierreAlturas","setCierreAlturas","calcularCierreAlturas","observacionesActualizadas","length","sumatoriaDistanciasVerticales","slice","reduce","acumulado","obs","distanciaVertical","alturaInstrumental","alturaPrisma","console","log","toFixed","calcularCierreAngular","observaciones","N","grados","minutos","segundos","contadorObservaciones","sumatoriaInicializada","forEach","angulo","sumarAngulos","restarAngulos","a1","a2","floor","convertirAGradosDecimales","mayor","menor","convertirGMSToDecimal","convertirDecimalAGMS","gradosDecimales","minutosDecimales","round","setObservaciones","setAlturaInstrumental","setAlturaPrisma","precisionPoligonal","setPrecisionPoligonal","idObservacion","setIdObservacion","calcularDistanciaVerticalZenital","anguloDecimal","anguloRad","convertirGradosARadianes","cos","calcularAlturaObservacion","PI","calcularCoordenadas","norteAnterior","esteAnterior","proyeccionNorte","proyeccionEste","nuevoNorte","nuevoEste","setContadorObservaciones","totalDistancia","setTotalDistancia","totalProyeccionNorte","setTotalProyeccionNorte","totalProyeccionEste","setTotalProyeccionEste","ultimoAzimut","setUltimoAzimut","calcularPrecision","distanciaTotal","proyeccionNorteTotal","proyeccionEsteTotal","sqrt","pow","calcularContraAzimut","azimut","contraAzimut","calcularAzimutSegundaObservacion","anguloObservadoDecimal","compensarProyeccionesYAlturas","nuevasObservaciones","errorNorte","errorEste","errorAlturas","total","distancia","alturaAcumulada","alturaCalculada","isNaN","error","index","id","alturaCompensada","distanciaVerticalCompensada","ajustarAlturasVerticales","ajusteAltura","abs","alturaCalculada1","proyeccionNorteCompensada","proyeccionEsteCompensada","ajusteNorte","ajusteEste","onSubmit","preventDefault","className","Fragment","margin","placeholder","agregarNuevaObservacion","undefined","alert","nuevoAzimutCalculado","calcularAzimutObservacion","anguloHorizontalDecimal","calcularNuevoAzimut","azimutSexagesimal","norte","este","calcularProyecciones","azimutRad","sin","nuevaObservacion","anguloHorizontal","anguloVertical","prevObservaciones","observacionesFiltradas","nuevasDistancias","acc","nuevasProyeccionesNorte","nuevasProyeccionesEste","nuevaPrecision","recalcularTotales","prevTotal","cellPadding","cellSpacing","key","borrarUltimaObservacion","ultimaObservacion","ultimoAzimutAnterior","ultimoAzimutDecimal","split","num","compensarPoligonal","compensarAngular","cantidadObservaciones","ajusteAngular","anguloHorizontalCompensado","anguloDec","anguloCompensadoGMS","observacionesFinales","recalcularCoordenadasAjustadas","proyeccionNorteAjustada","proyeccionEsteAjustada","test","required","calcularAzimutYAlmacenarValores","calcularAzimutYDistanciaDesdeCoordenadas","deltaX","deltaY","azimutDeg","atan2","App","observacion","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.3487ca9f.chunk.js","sourcesContent":["import React, { useState } from \"react\";\r\nimport ReactTooltip from \"react-tooltip\";\r\nimport { UncontrolledReactSVGPanZoom } from \"react-svg-pan-zoom\"; // Pan y zoom para el SVG\r\n\r\nconst GraficoPoligonal = ({ observacionesCompensadas = [] }) => {\r\n  const [colorLinea, setColorLinea] = useState(\"blue\");\r\n  const [grosorLinea, setGrosorLinea] = useState(2);\r\n  const [colorPunto, setColorPunto] = useState(\"red\");\r\n  const [tamañoFlecha, setTamañoFlecha] = useState(10);\r\n  const [colorFlecha, setColorFlecha] = useState(\"blue\");\r\n  const [mostrarFlecha, setMostrarFlecha] = useState(true);\r\n  const [mostrarMenu, setMostrarMenu] = useState(false); // Estado para controlar la visibilidad del menú\r\n\r\n  const anchoSVG = 300;\r\n  const altoSVG = 550;\r\n  const gridSpacing = 100; // Espaciado de la cuadrícula\r\n\r\n  // Calcula los valores mínimos y máximos de las coordenadas ajustadas\r\n  const minX = Math.min(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoEsteAjustado))\r\n  );\r\n  const maxX = Math.max(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoEsteAjustado))\r\n  );\r\n  const minY = Math.min(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoNorteAjustado))\r\n  );\r\n  const maxY = Math.max(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoNorteAjustado))\r\n  );\r\n\r\n  // Agrega un margen del 10% alrededor de los extremos\r\n  const margen = 0.1; // 10% de margen\r\n\r\n  const rangoX = (maxX - minX) * (1 + margen);\r\n  const rangoY = (maxY - minY) * (1 + margen);\r\n\r\n  // Calcula la escala para ajustar la poligonal al tamaño del SVG\r\n  const escala = Math.min(anchoSVG / rangoX, altoSVG / rangoY);\r\n\r\n  // Centra la poligonal en el SVG\r\n  const offsetX = (anchoSVG - (maxX - minX) * escala) / 2;\r\n  const offsetY = (altoSVG - (maxY - minY) * escala) / 2;\r\n\r\n  // Función para escalar las coordenadas al tamaño del SVG\r\n  const escalarX = (valor) => (valor - minX) * escala + offsetX;\r\n  const escalarY = (valor) => altoSVG - (valor - minY) * escala - offsetY; // Invertir el eje Y para el SVG\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        position: \"relative\",\r\n        border: \"2px solid black\",\r\n        width: `${anchoSVG}px`,\r\n        height: `${altoSVG}px`,\r\n        padding: \"10px\",\r\n      }}\r\n    >\r\n      {/* Botón para mostrar/ocultar el menú */}\r\n      <button\r\n        onClick={() => setMostrarMenu(!mostrarMenu)} // Alternar visibilidad del menú\r\n        style={{\r\n          position: \"absolute\",\r\n          top: \"5px\",\r\n          right: \"5px\",\r\n          zIndex: 11, // Asegura que esté encima del SVG\r\n        }}\r\n      >\r\n        {mostrarMenu ? \"Ocultar Configuración\" : \"Mostrar Configuración\"}\r\n      </button>\r\n\r\n      {/* Menú de configuración flotante */}\r\n      {mostrarMenu && (\r\n        <div\r\n          style={{\r\n            position: \"absolute\",\r\n            top: \"40px\",\r\n            left: \"5px\",\r\n            backgroundColor: \"white\",\r\n            padding: \"10px\",\r\n            borderRadius: \"8px\",\r\n            boxShadow: \"0px 4px 10px rgba(0, 0, 0, 0.1)\",\r\n            zIndex: 10,\r\n            fontSize: \"10px\",\r\n          }}\r\n        >\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Color de la línea:\r\n            <input\r\n              type=\"color\"\r\n              value={colorLinea}\r\n              onChange={(e) => setColorLinea(e.target.value)}\r\n              style={{ width: \"40%\", marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Grosor de la línea:\r\n            <input\r\n              type=\"number\"\r\n              min=\"1\"\r\n              max=\"50\"\r\n              value={grosorLinea}\r\n              onChange={(e) => setGrosorLinea(Number(e.target.value))}\r\n              style={{ width: \"30%\", marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Color del punto:\r\n            <input\r\n              type=\"color\"\r\n              value={colorPunto}\r\n              onChange={(e) => setColorPunto(e.target.value)}\r\n              style={{ width: \"40%\", marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Tamaño de la flecha:\r\n            <input\r\n              type=\"number\"\r\n              min=\"5\"\r\n              max=\"40\"\r\n              value={tamañoFlecha}\r\n              onChange={(e) => setTamañoFlecha(Number(e.target.value))}\r\n              style={{ width: \"30%\", marginTop: \"2px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Color de la flecha:\r\n            <input\r\n              type=\"color\"\r\n              value={colorFlecha}\r\n              onChange={(e) => setColorFlecha(e.target.value)}\r\n              style={{ width: \"40%\", marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Mostrar flecha:\r\n            <input\r\n              type=\"checkbox\"\r\n              checked={mostrarFlecha}\r\n              onChange={(e) => setMostrarFlecha(e.target.checked)}\r\n              style={{ marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n        </div>\r\n      )}\r\n\r\n      {/* Renderización del SVG con pan y zoom */}\r\n      <UncontrolledReactSVGPanZoom\r\n        width={anchoSVG}\r\n        height={altoSVG}\r\n        background=\"transparent\"\r\n        tool=\"auto\"\r\n        detectAutoPan={false}\r\n        toolbarProps={{ position: \"none\" }} // Ocultar los botones de la herramienta\r\n      >\r\n        <svg width={anchoSVG} height={altoSVG} style={{ zIndex: 1 }}>\r\n          {/* Aquí va tu código SVG como antes */}\r\n          {/* Renderización de la cuadrícula, puntos y líneas */}\r\n        </svg>\r\n      </UncontrolledReactSVGPanZoom>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GraficoPoligonal;\r\n","import React, { useState } from \"react\";\r\nimport GraficoPoligonal from \"./GraficoPoligonalSVG\";\r\n\r\nconst FormularioObservacion = ({ agregarObservacion }) => {\r\n  // Estados para coordenadas y observaciones\r\n  const [norteInicial, setNorteInicial] = useState(\"\");\r\n  const [esteInicial, setEsteInicial] = useState(\"\");\r\n  const [norteVisado, setNorteVisado] = useState(\"\");\r\n  const [esteVisado, setEsteVisado] = useState(\"\");\r\n\r\n  const [azimutInicial, setAzimutInicial] = useState(null); // Estado para el azimut inicial\r\n  const [distanciaInicial, setDistanciaInicial] = useState(null); // Estado para la distancia inicial\r\n  const [coordenadasCalculadas, setCoordenadasCalculadas] = useState(false); // Para controlar si ya calculaste las coordenadas\r\n\r\n  // Estados para los ángulos y la distancia observada\r\n  const [gradosH, setGradosH] = useState(\"\");\r\n  const [minutosH, setMinutosH] = useState(\"\");\r\n  const [segundosH, setSegundosH] = useState(\"\");\r\n\r\n  const [gradosV, setGradosV] = useState(\"\");\r\n  const [minutosV, setMinutosV] = useState(\"\");\r\n  const [segundosV, setSegundosV] = useState(\"\");\r\n\r\n  const [distanciaObservada, setDistanciaObservada] = useState(\"\");\r\n  const [alturaInicial, setAlturaInicial] = useState(\"\"); // Nueva variable para la altura inicial\r\n\r\n  const [nuevoAzimut, setNuevoAzimut] = useState(null); // Estado para el nuevo azimut calculado\r\n\r\n  const [sumaTeorica, setSumaTeorica] = useState(0);\r\n  const [sumaReal, setSumaReal] = useState(0);\r\n  const [errorAngular, setErrorAngular] = useState(0);\r\n\r\n  const [sentidoPoligonal, setSentidoPoligonal] = useState(\"internos\"); // 'internos' o 'externos'\r\n  const [observacionesCompensadas, setObservacionesCompensadas] = useState([]); // Para las observaciones ajustadas\r\n  // Suponiendo que tienes estos estados definidos en algún lugar del componente\r\n  const [brazoExterno, setBrazoExterno] = useState(false); // Por defecto, el brazo es interno\r\n  const [cierreAlturas, setCierreAlturas] = useState(0); // Estado para almacenar el cierre de alturas\r\n\r\n  const calcularCierreAlturas = (observacionesActualizadas) => {\r\n    if (observacionesActualizadas.length === 0) {\r\n      setCierreAlturas(0); // Si no hay observaciones, el cierre de alturas es 0\r\n      return 0;\r\n    }\r\n\r\n    // Filtrar las observaciones según el tipo de brazo\r\n    const observacionesAConsiderar = brazoExterno\r\n      ? observacionesActualizadas.slice(1) // Si es brazo externo, omitimos la primera observación\r\n      : observacionesActualizadas; // Si es brazo interno, usamos todas las observaciones\r\n\r\n    // Calcular la sumatoria de las distancias verticales reales (valor absoluto)\r\n    const sumatoriaDistanciasVerticales = observacionesAConsiderar.reduce(\r\n      (acumulado, obs) =>\r\n        acumulado +\r\n        parseFloat(obs.distanciaVertical) + // Tomamos el valor absoluto de la distancia vertical\r\n        parseFloat(obs.alturaInstrumental) -\r\n        parseFloat(obs.alturaPrisma),\r\n      0\r\n    );\r\n\r\n    console.log(\r\n      `\\nSumatoria de Distancias Verticales Calculadas: ${sumatoriaDistanciasVerticales.toFixed(\r\n        4\r\n      )}`\r\n    );\r\n\r\n    // Guardar y retornar el cierre de alturas manteniendo el signo\r\n    const cierreAlturas = sumatoriaDistanciasVerticales.toFixed(4);\r\n    setCierreAlturas(cierreAlturas);\r\n\r\n    console.log(`Cierre de alturas calculado: ${cierreAlturas}`);\r\n\r\n    return parseFloat(cierreAlturas); // Retornamos el valor numérico con su signo\r\n  };\r\n\r\n  const calcularCierreAngular = (observaciones, sentidoPoligonal) => {\r\n    const N = observaciones.length;\r\n    if (N === 0) return;\r\n\r\n    // Inicializamos la sumatoria de los ángulos con 0° 0' 0\"\r\n    let sumaReal = { grados: 0, minutos: 0, segundos: 0 };\r\n\r\n    // Contador para rastrear el número de observaciones\r\n    let contadorObservaciones = 0;\r\n\r\n    // Bandera para saber si ya hemos inicializado la suma con la segunda observación\r\n    let sumatoriaInicializada = false;\r\n\r\n    // Iteramos sobre las observaciones\r\n    observaciones.forEach((obs) => {\r\n      contadorObservaciones++; // Incrementamos el contador por cada observación\r\n\r\n      // Si es la primera observación y el brazo es externo, la ignoramos\r\n      if (contadorObservaciones === 0 && brazoExterno) {\r\n        return; // Salta la primera observación\r\n      }\r\n\r\n      // Convertir los valores del ángulo de la observación actual\r\n      const angulo = {\r\n        grados: Number(obs.gradosH),\r\n        minutos: Number(obs.minutosH),\r\n        segundos: Number(obs.segundosH),\r\n      };\r\n\r\n      // Si es la segunda observación y la primera fue omitida, inicializamos la sumatoria\r\n      if (\r\n        contadorObservaciones === 0 &&\r\n        brazoExterno &&\r\n        !sumatoriaInicializada\r\n      ) {\r\n        sumaReal = angulo; // Iniciamos la sumatoria con el ángulo de la segunda observación\r\n        sumatoriaInicializada = true; // Marcamos que ya hemos inicializado la sumatoria\r\n      } else {\r\n        // Para todas las demás observaciones, sumamos los ángulos normalmente\r\n        sumaReal = sumarAngulos(sumaReal, angulo);\r\n      }\r\n    });\r\n\r\n    // Calculamos la suma teórica dependiendo del tipo de poligonal\r\n    let sumaTeorica;\r\n    if (sentidoPoligonal === \"internos\") {\r\n      sumaTeorica = { grados: (N - 2) * 180, minutos: 0, segundos: 0 };\r\n    } else {\r\n      sumaTeorica = { grados: (N + 2) * 180, minutos: 0, segundos: 0 };\r\n    }\r\n\r\n    // Calculamos el error angular\r\n    const errorAngular = restarAngulos(sumaTeorica, sumaReal);\r\n\r\n    // Actualizamos los estados con los valores finales\r\n    setSumaTeorica(sumaTeorica);\r\n    setSumaReal(sumaReal);\r\n    setErrorAngular(errorAngular);\r\n  };\r\n\r\n  const sumarAngulos = (a1, a2) => {\r\n    let segundos = Number(a1.segundos) + Number(a2.segundos);\r\n    let minutos = Number(a1.minutos) + Number(a2.minutos);\r\n    let grados = Number(a1.grados) + Number(a2.grados);\r\n\r\n    // Ajustar segundos si exceden 60\r\n    if (segundos >= 60) {\r\n      minutos += Math.floor(segundos / 60);\r\n      segundos = segundos % 60;\r\n    }\r\n\r\n    // Ajustar minutos si exceden 60\r\n    if (minutos >= 60) {\r\n      grados += Math.floor(minutos / 60);\r\n      minutos = minutos % 60;\r\n    }\r\n\r\n    return { grados, minutos, segundos };\r\n  };\r\n\r\n  const convertirAGradosDecimales = (grados, minutos, segundos) => {\r\n    return grados + minutos / 60 + segundos / 3600;\r\n  };\r\n\r\n  const restarAngulos = (a1, a2) => {\r\n    // Convertir los ángulos a grados decimales para compararlos\r\n    const angulo1Decimal = convertirAGradosDecimales(\r\n      a1.grados,\r\n      a1.minutos,\r\n      a1.segundos\r\n    );\r\n    const angulo2Decimal = convertirAGradosDecimales(\r\n      a2.grados,\r\n      a2.minutos,\r\n      a2.segundos\r\n    );\r\n\r\n    // Determinar cuál es el mayor y el menor\r\n    let mayor, menor;\r\n    if (angulo1Decimal >= angulo2Decimal) {\r\n      mayor = a1;\r\n      menor = a2;\r\n    } else {\r\n      mayor = a2;\r\n      menor = a1;\r\n    }\r\n\r\n    // Restar ángulos (siempre mayor - menor)\r\n    let segundos = mayor.segundos - menor.segundos;\r\n    let minutos = mayor.minutos - menor.minutos;\r\n    let grados = mayor.grados - menor.grados;\r\n\r\n    // Si los segundos son negativos, pedir prestado 1 minuto\r\n    if (segundos < 0) {\r\n      segundos += 60;\r\n      minutos -= 1;\r\n    }\r\n\r\n    // Si los minutos son negativos, pedir prestado 1 grado\r\n    if (minutos < 0) {\r\n      minutos += 60;\r\n      grados -= 1;\r\n    }\r\n\r\n    return { grados, minutos, segundos };\r\n  };\r\n\r\n  // Función para convertir GMS a grados decimales\r\n  const convertirGMSToDecimal = (grados, minutos, segundos) => {\r\n    return (\r\n      parseFloat(grados) +\r\n      parseFloat(minutos) / 60 +\r\n      parseFloat(segundos) / 3600\r\n    );\r\n  };\r\n  const convertirDecimalAGMS = (gradosDecimales) => {\r\n    const grados = Math.floor(gradosDecimales); // Parte entera para los grados\r\n    const minutosDecimales = (gradosDecimales - grados) * 60;\r\n    const minutos = Math.floor(minutosDecimales); // Parte entera para los minutos\r\n    const segundos = Math.round((minutosDecimales - minutos) * 60); // Redondear los segundos a enteros\r\n\r\n    return `${grados}° ${minutos}' ${segundos}\"`;\r\n  };\r\n\r\n  // Estado para almacenar todas las observaciones\r\n  const [observaciones, setObservaciones] = useState([]);\r\n\r\n  // Estados para las alturas\r\n  const [alturaInstrumental, setAlturaInstrumental] = useState(\"\");\r\n  const [alturaPrisma, setAlturaPrisma] = useState(\"\");\r\n\r\n  // Estado para almacenar la precisión de la poligonal\r\n  const [precisionPoligonal, setPrecisionPoligonal] = useState(0);\r\n\r\n  // Estado para el ID de la observación\r\n  const [idObservacion, setIdObservacion] = useState(\"\");\r\n\r\n  // Función para calcular el azimut inicial y la distancia a partir de coordenadas\r\n  const calcularAzimutYDistanciaDesdeCoordenadas = (\r\n    norteInicial,\r\n    esteInicial,\r\n    norteVisado,\r\n    esteVisado\r\n  ) => {\r\n    const deltaX = parseFloat(esteVisado) - parseFloat(esteInicial);\r\n    const deltaY = parseFloat(norteVisado) - parseFloat(norteInicial);\r\n\r\n    // Azimut inicial en grados\r\n    let azimutRad = Math.atan2(deltaX, deltaY);\r\n    let azimutDeg = azimutRad * (180 / Math.PI); // Convertimos de radianes a grados\r\n\r\n    // Ajustar el azimut para que esté en el rango de 0 a 360 grados\r\n    if (azimutDeg < 0) {\r\n      azimutDeg += 360;\r\n    } else if (azimutDeg >= 360) {\r\n      azimutDeg -= 360;\r\n    }\r\n\r\n    // Calcular la distancia entre D1 y D2\r\n    const distancia = Math.sqrt(deltaX ** 2 + deltaY ** 2);\r\n\r\n    // Retornar el azimut y la distancia\r\n    return {\r\n      azimut: azimutDeg.toFixed(4), // Redondear azimut a 4 decimales\r\n      distancia: distancia.toFixed(4), // Redondear distancia a 4 decimales\r\n    };\r\n  };\r\n\r\n  // Función que calcula y almacena azimut y distancia\r\n  const calcularAzimutYAlmacenarValores = () => {\r\n    const { azimut, distancia } = calcularAzimutYDistanciaDesdeCoordenadas(\r\n      norteInicial,\r\n      esteInicial,\r\n      norteVisado,\r\n      esteVisado\r\n    );\r\n\r\n    // Almacenar los valores calculados en el estado\r\n    setAzimutInicial(azimut);\r\n    setDistanciaInicial(distancia);\r\n\r\n    setCoordenadasCalculadas(true); // Cambiar el estado para ocultar los inputs de coordenadas si corresponde\r\n  };\r\n\r\n  // Función para calcular la distancia vertical zenital\r\n  const calcularDistanciaVerticalZenital = (\r\n    grados,\r\n    minutos,\r\n    segundos,\r\n    distanciaObservada\r\n  ) => {\r\n    // Convertimos los grados a decimales\r\n    const anguloDecimal = convertirGMSToDecimal(grados, minutos, segundos);\r\n\r\n    // Convertimos el ángulo a radianes\r\n    const anguloRad = convertirGradosARadianes(anguloDecimal);\r\n\r\n    // Calculamos la distancia vertical usando el coseno del ángulo\r\n    const distanciaVertical = distanciaObservada * Math.cos(anguloRad);\r\n\r\n    return distanciaVertical.toFixed(4); // Redondear a 4 decimales\r\n  };\r\n\r\n  const calcularAlturaObservacion = (\r\n    alturaInicial,\r\n    distanciaVertical,\r\n    alturaInstrumental,\r\n    alturaPrisma\r\n  ) => {\r\n    // Calcular la altura final sobre el piso\r\n    const alturaFinal =\r\n      parseFloat(alturaInicial) +\r\n      parseFloat(alturaInstrumental) -\r\n      parseFloat(alturaPrisma) +\r\n      parseFloat(distanciaVertical);\r\n    return alturaFinal.toFixed(4); // Redondear a 4 decimales\r\n  };\r\n\r\n  // Función para calcular el nuevo azimut basado en el azimut inicial y el ángulo observado\r\n  const calcularNuevoAzimut = (azimutInicial, anguloObservadoDecimal) => {\r\n    let nuevoAzimut = azimutInicial + anguloObservadoDecimal;\r\n\r\n    // Si el azimut es mayor o igual a 360, restamos 360 para ajustarlo\r\n    if (nuevoAzimut >= 360) {\r\n      nuevoAzimut -= 360;\r\n    }\r\n\r\n    return nuevoAzimut.toFixed(4); // Retornamos el nuevo azimut en grados decimales\r\n  };\r\n\r\n  // Función para calcular y almacenar el nuevo azimut basado en la observación\r\n  const calcularAzimutObservacion = () => {\r\n    // Convertir ángulo observado (horizontal) a grados decimales\r\n    const anguloHorizontalDecimal = convertirGMSToDecimal(\r\n      gradosH,\r\n      minutosH,\r\n      segundosH\r\n    );\r\n\r\n    // Calcular el nuevo azimut basado en el ángulo observado y el azimut inicial\r\n    const nuevoAzimutCalculado = calcularNuevoAzimut(\r\n      parseFloat(azimutInicial),\r\n      anguloHorizontalDecimal\r\n    );\r\n\r\n    // Guardar el nuevo azimut en el estado\r\n    setNuevoAzimut(nuevoAzimutCalculado);\r\n\r\n    return nuevoAzimutCalculado;\r\n  };\r\n\r\n  // Función para convertir grados a radianes\r\n  const convertirGradosARadianes = (grados) => {\r\n    return (grados * Math.PI) / 180;\r\n  };\r\n\r\n  // Función para calcular las proyecciones Norte y Este\r\n  const calcularProyecciones = (azimut, distancia) => {\r\n    const azimutRad = convertirGradosARadianes(azimut); // Convertir el azimut a radianes\r\n\r\n    // Proyección Norte (coseno del azimut por la distancia)\r\n    const proyeccionNorte = Math.cos(azimutRad) * distancia;\r\n\r\n    // Proyección Este (seno del azimut por la distancia)\r\n    const proyeccionEste = Math.sin(azimutRad) * distancia;\r\n\r\n    // Retornamos las proyecciones redondeadas a 4 decimales\r\n    return {\r\n      norte: proyeccionNorte.toFixed(4),\r\n      este: proyeccionEste.toFixed(4),\r\n    };\r\n  };\r\n\r\n  // Función para calcular las nuevas coordenadas\r\n  const calcularCoordenadas = (\r\n    norteAnterior,\r\n    esteAnterior,\r\n    proyeccionNorte,\r\n    proyeccionEste\r\n  ) => {\r\n    const nuevoNorte = parseFloat(norteAnterior) + parseFloat(proyeccionNorte);\r\n    const nuevoEste = parseFloat(esteAnterior) + parseFloat(proyeccionEste);\r\n\r\n    return {\r\n      nuevoNorte: nuevoNorte.toFixed(4), // Redondear a 4 decimales\r\n      nuevoEste: nuevoEste.toFixed(4), // Redondear a 4 decimales\r\n    };\r\n  };\r\n  const [contadorObservaciones, setContadorObservaciones] = useState(0); // Contador para saber cuántas observaciones se han hecho\r\n  // Estados para los totales\r\n  const [totalDistancia, setTotalDistancia] = useState(0);\r\n  const [totalProyeccionNorte, setTotalProyeccionNorte] = useState(0);\r\n  const [totalProyeccionEste, setTotalProyeccionEste] = useState(0);\r\n\r\n  // Estado para almacenar el último azimut calculado (usado para las siguientes observaciones)\r\n  const [ultimoAzimut, setUltimoAzimut] = useState(null);\r\n\r\n  const recalcularTotales = (nuevasObservaciones) => {\r\n    // Filtrar la primera observación si el brazo es externo\r\n    const observacionesFiltradas = brazoExterno\r\n      ? nuevasObservaciones.slice(1)\r\n      : nuevasObservaciones;\r\n\r\n    calcularCierreAngular(observacionesFiltradas, sentidoPoligonal);\r\n    calcularCierreAlturas(observacionesFiltradas, alturaInicial);\r\n\r\n    const nuevasDistancias = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.distancia),\r\n      0\r\n    );\r\n\r\n    const nuevasProyeccionesNorte = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.proyeccionNorte),\r\n      0\r\n    );\r\n    const nuevasProyeccionesEste = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.proyeccionEste),\r\n      0\r\n    );\r\n\r\n    setTotalDistancia(nuevasDistancias);\r\n    setTotalProyeccionNorte(nuevasProyeccionesNorte);\r\n    setTotalProyeccionEste(nuevasProyeccionesEste);\r\n\r\n    const nuevaPrecision = calcularPrecision(\r\n      nuevasDistancias,\r\n      nuevasProyeccionesNorte,\r\n      nuevasProyeccionesEste\r\n    );\r\n    setPrecisionPoligonal(nuevaPrecision);\r\n  };\r\n\r\n  const agregarNuevaObservacion = () => {\r\n    // Validaciones\r\n    if (\r\n      gradosH === undefined ||\r\n      minutosH === undefined ||\r\n      segundosH === undefined ||\r\n      gradosV === undefined ||\r\n      minutosV === undefined ||\r\n      segundosV === undefined ||\r\n      distanciaObservada === \"\" ||\r\n      isNaN(distanciaObservada)\r\n    ) {\r\n      alert(\"Por favor, completa todos los campos con valores válidos.\");\r\n      return;\r\n    }\r\n\r\n    // Conversión de ángulo horizontal a decimal\r\n    const anguloObservadoDecimal = convertirGMSToDecimal(\r\n      Number(gradosH),\r\n      Number(minutosH),\r\n      Number(segundosH)\r\n    );\r\n    let nuevoAzimutCalculado;\r\n\r\n    if (contadorObservaciones === 0) {\r\n      nuevoAzimutCalculado = calcularAzimutObservacion();\r\n    } else {\r\n      const contraAzimut = calcularContraAzimut(ultimoAzimut);\r\n      nuevoAzimutCalculado = calcularAzimutSegundaObservacion(\r\n        contraAzimut,\r\n        anguloObservadoDecimal\r\n      );\r\n    }\r\n\r\n    const azimutSexagesimal = convertirDecimalAGMS(nuevoAzimutCalculado);\r\n\r\n    // Proyecciones Norte y Este\r\n    const { norte, este } = calcularProyecciones(\r\n      parseFloat(nuevoAzimutCalculado),\r\n      parseFloat(distanciaObservada)\r\n    );\r\n\r\n    // Cálculo de nuevas coordenadas\r\n    let nuevoNorte, nuevoEste;\r\n    if (contadorObservaciones === 0) {\r\n      ({ nuevoNorte, nuevoEste } = calcularCoordenadas(\r\n        norteInicial,\r\n        esteInicial,\r\n        norte,\r\n        este\r\n      ));\r\n    } else {\r\n      const { nuevoNorte: norteAnterior, nuevoEste: esteAnterior } =\r\n        observaciones[observaciones.length - 1];\r\n      ({ nuevoNorte, nuevoEste } = calcularCoordenadas(\r\n        norteAnterior,\r\n        esteAnterior,\r\n        norte,\r\n        este\r\n      ));\r\n    }\r\n\r\n    // Cálculo de la distancia vertical\r\n    const distanciaVertical = calcularDistanciaVerticalZenital(\r\n      gradosV,\r\n      minutosV,\r\n      segundosV,\r\n      distanciaObservada\r\n    );\r\n\r\n    // Cálculo de la altura\r\n    const alturaCalculada = calcularAlturaObservacion(\r\n      contadorObservaciones === 0\r\n        ? alturaInicial\r\n        : observaciones[observaciones.length - 1].alturaCalculada,\r\n      distanciaVertical,\r\n      alturaInstrumental,\r\n      alturaPrisma\r\n    );\r\n\r\n    // Crear el objeto de la nueva observación\r\n    const nuevaObservacion = {\r\n      id: idObservacion,\r\n      gradosH,\r\n      minutosH,\r\n      segundosH,\r\n      gradosV,\r\n      minutosV,\r\n      segundosV,\r\n      azimut: azimutSexagesimal,\r\n      anguloHorizontal: `${gradosH}° ${minutosH}' ${segundosH}\"`,\r\n      anguloVertical: `${gradosV}° ${minutosV}' ${segundosV}\"`,\r\n      distancia: distanciaObservada,\r\n      distanciaVertical, // Añadir la distancia vertical calculada aquí\r\n      alturaInstrumental,\r\n      alturaPrisma,\r\n      proyeccionNorte: norte,\r\n      proyeccionEste: este,\r\n      nuevoNorte,\r\n      nuevoEste,\r\n      alturaCalculada, // Guardar la altura calculada\r\n      alturaCalculada1: (\r\n        parseFloat(alturaInstrumental) +\r\n        parseFloat(distanciaVertical) -\r\n        parseFloat(alturaPrisma)\r\n      ).toFixed(4),\r\n    };\r\n\r\n    // Actualizar observaciones y recalcular totales\r\n    setObservaciones((prevObservaciones) => {\r\n      const nuevasObservaciones = [...prevObservaciones, nuevaObservacion];\r\n\r\n      // Llamamos a recalcularTotales después de agregar la nueva observación\r\n      recalcularTotales(nuevasObservaciones);\r\n      // Aquí calculamos el cierre de alturas con la observación recién agregada\r\n      calcularCierreAlturas(nuevasObservaciones);\r\n\r\n      return nuevasObservaciones;\r\n    });\r\n\r\n    // Actualización de totales directamente\r\n    setTotalDistancia(\r\n      (prevTotal) => prevTotal + parseFloat(distanciaObservada)\r\n    );\r\n    setTotalProyeccionNorte((prevTotal) => prevTotal + parseFloat(norte));\r\n    setTotalProyeccionEste((prevTotal) => prevTotal + parseFloat(este));\r\n\r\n    // Actualización de precisión\r\n    const nuevaPrecision = calcularPrecision(\r\n      totalDistancia + parseFloat(distanciaObservada),\r\n      totalProyeccionNorte + parseFloat(norte),\r\n      totalProyeccionEste + parseFloat(este)\r\n    );\r\n    setPrecisionPoligonal(nuevaPrecision);\r\n\r\n    setUltimoAzimut(parseFloat(nuevoAzimutCalculado));\r\n    setContadorObservaciones(contadorObservaciones + 1);\r\n\r\n    // Limpiar los campos de los inputs\r\n    setIdObservacion(\"\");\r\n    setGradosH(\"\");\r\n    setMinutosH(\"\");\r\n    setSegundosH(\"\");\r\n    setGradosV(\"\");\r\n    setMinutosV(\"\");\r\n    setSegundosV(\"\");\r\n    setDistanciaObservada(\"\");\r\n    setAlturaInstrumental(\"\");\r\n    setAlturaPrisma(\"\");\r\n  };\r\n\r\n  // Función para calcular la precisión de la poligonal\r\n  const calcularPrecision = (\r\n    distanciaTotal,\r\n    proyeccionNorteTotal,\r\n    proyeccionEsteTotal\r\n  ) => {\r\n    const sumatoriaProyecciones = Math.sqrt(\r\n      Math.pow(proyeccionNorteTotal, 2) + Math.pow(proyeccionEsteTotal, 2)\r\n    );\r\n    const precision = distanciaTotal / sumatoriaProyecciones;\r\n    return precision.toFixed(4); // Redondeamos a 4 decimales\r\n  };\r\n\r\n  const calcularContraAzimut = (azimut) => {\r\n    let contraAzimut;\r\n\r\n    if (azimut < 180) {\r\n      contraAzimut = azimut + 180;\r\n    } else {\r\n      contraAzimut = azimut - 180;\r\n    }\r\n\r\n    // Aseguramos que el contra-azimut esté en el rango de 0 a 360 grados\r\n    if (contraAzimut >= 360) {\r\n      contraAzimut -= 360;\r\n    }\r\n\r\n    return contraAzimut.toFixed(4); // Retornamos el contra-azimut redondeado a 4 decimales\r\n  };\r\n\r\n  const calcularAzimutSegundaObservacion = (\r\n    contraAzimut,\r\n    anguloObservadoDecimal\r\n  ) => {\r\n    let nuevoAzimut =\r\n      parseFloat(contraAzimut) + parseFloat(anguloObservadoDecimal);\r\n\r\n    // Si el nuevo azimut es mayor o igual a 360, restamos 360\r\n    if (nuevoAzimut >= 360) {\r\n      nuevoAzimut -= 360;\r\n    }\r\n\r\n    return nuevoAzimut.toFixed(4); // Retornamos el nuevo azimut redondeado a 4 decimales\r\n  };\r\n\r\n  const borrarUltimaObservacion = () => {\r\n    if (observaciones.length > 0) {\r\n      const ultimaObservacion = observaciones[observaciones.length - 1];\r\n\r\n      // Restar la distancia y proyecciones de la última observación\r\n      setTotalDistancia((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.distancia))\r\n      );\r\n      setTotalProyeccionNorte((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.proyeccionNorte))\r\n      );\r\n      setTotalProyeccionEste((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.proyeccionEste))\r\n      );\r\n\r\n      // Crear una nueva lista sin la última observación\r\n      const nuevasObservaciones = observaciones.slice(0, -1);\r\n      setObservaciones(nuevasObservaciones);\r\n\r\n      // Recalcular la precisión de la poligonal\r\n      const nuevaPrecision = calcularPrecision(\r\n        Math.max(0, totalDistancia - parseFloat(ultimaObservacion.distancia)),\r\n        Math.max(\r\n          0,\r\n          totalProyeccionNorte - parseFloat(ultimaObservacion.proyeccionNorte)\r\n        ),\r\n        Math.max(\r\n          0,\r\n          totalProyeccionEste - parseFloat(ultimaObservacion.proyeccionEste)\r\n        )\r\n      );\r\n      setPrecisionPoligonal(nuevaPrecision);\r\n\r\n      // Actualizar el contador de observaciones\r\n      setContadorObservaciones(contadorObservaciones - 1);\r\n\r\n      // Si todavía hay observaciones, actualiza el último azimut\r\n      if (nuevasObservaciones.length > 0) {\r\n        const ultimoAzimutAnterior =\r\n          nuevasObservaciones[nuevasObservaciones.length - 1].azimut;\r\n        const ultimoAzimutDecimal = convertirGMSToDecimal(\r\n          ...ultimoAzimutAnterior.split(/[°'\"]/).map((num) => parseFloat(num))\r\n        );\r\n        setUltimoAzimut(ultimoAzimutDecimal);\r\n      } else {\r\n        setUltimoAzimut(null);\r\n      }\r\n\r\n      // --- Recalcular el cierre angular ---\r\n      // Actualizamos el resumen angular de la poligonal después de eliminar la observación\r\n      calcularCierreAngular(nuevasObservaciones, sentidoPoligonal);\r\n    }\r\n  };\r\n\r\n  const compensarAngular = () => {\r\n    const N = observaciones.length;\r\n\r\n    // Evitar divisiones por cero si no hay observaciones\r\n    if (N === 0) return [];\r\n\r\n    // Si es brazo externo, omitimos el primer ángulo para la compensación\r\n    const observacionesACompensar = brazoExterno\r\n      ? observaciones.slice(1)\r\n      : observaciones;\r\n    const cantidadObservaciones = observacionesACompensar.length;\r\n\r\n    // Ajuste angular basado en la cantidad de ángulos a compensar (si brazo externo, N-1)\r\n    const ajusteAngular =\r\n      convertirAGradosDecimales(\r\n        errorAngular.grados,\r\n        errorAngular.minutos,\r\n        errorAngular.segundos\r\n      ) / cantidadObservaciones; // Ajuste en grados decimales basado en la cantidad de observaciones a compensar\r\n\r\n    // Crear un nuevo array de observaciones compensadas\r\n    const nuevasObservaciones = observaciones.map((obs, index) => {\r\n      // Si es la primera observación y el brazo es externo, devolverla sin cambios (mantener el ángulo tal cual)\r\n      if (index === 0 && brazoExterno) {\r\n        return {\r\n          ...obs,\r\n          anguloHorizontalCompensado: obs.anguloHorizontal, // Mantener el ángulo original\r\n        };\r\n      }\r\n\r\n      // Convertir el ángulo horizontal actual a decimal\r\n      const [grados, minutos, segundos] = obs.anguloHorizontal\r\n        .split(/[°'\"]/)\r\n        .map(parseFloat);\r\n\r\n      const anguloDec = convertirAGradosDecimales(grados, minutos, segundos);\r\n\r\n      // Aplicar el ajuste en grados decimales\r\n      const anguloCompensadoDec = anguloDec - ajusteAngular;\r\n\r\n      // Convertir de nuevo a GMS\r\n      const anguloCompensadoGMS = convertirDecimalAGMS(anguloCompensadoDec);\r\n\r\n      // Retornar la observación con el ángulo compensado\r\n      return {\r\n        ...obs,\r\n        anguloHorizontalCompensado: anguloCompensadoGMS, // Guardamos el ángulo compensado en GMS\r\n      };\r\n    });\r\n\r\n    return nuevasObservaciones; // Devolver las observaciones ajustadas\r\n  };\r\n  const ajustarAlturasVerticales = (observacionesCompensadas) => {\r\n    let alturaAcumulada;\r\n\r\n    // Usar la altura real de la primera observación como base si el brazo es externo\r\n    if (brazoExterno) {\r\n      alturaAcumulada = parseFloat(observacionesCompensadas[0].alturaCalculada);\r\n      console.log(\r\n        `\\n*** Brazo Externo: Usando altura de la primera observación como base: ${alturaAcumulada} ***`\r\n      );\r\n    } else {\r\n      // Si es brazo interno, partimos de la altura real calculada en la primera observación\r\n      alturaAcumulada = parseFloat(observacionesCompensadas[0].alturaCalculada);\r\n      console.log(\r\n        `\\n*** Brazo Interno: Usando altura inicial de la primera observación: ${alturaAcumulada} ***`\r\n      );\r\n    }\r\n\r\n    // Validar que la altura base sea válida\r\n    if (isNaN(alturaAcumulada)) {\r\n      console.error(\"Error: Altura inicial no válida.\");\r\n      alturaAcumulada = 0; // Manejo de error básico\r\n    }\r\n\r\n    // Ajustar las alturas progresivamente\r\n    const nuevasObservaciones = observacionesCompensadas.map((obs, index) => {\r\n      console.log(\r\n        `\\nCalculando altura compensada para la observación ${obs.id}`\r\n      );\r\n\r\n      if (index === 0 && brazoExterno) {\r\n        // La primera observación no se ajusta si el brazo es externo\r\n        obs.alturaCompensada = obs.alturaCalculada;\r\n        console.log(\r\n          `Brazo Externo - Primera observación sin ajuste: ${obs.alturaCompensada}`\r\n        );\r\n      } else {\r\n        // Validar la distancia vertical compensada\r\n        const distanciaVerticalCompensada = parseFloat(\r\n          obs.distanciaVerticalCompensada\r\n        );\r\n        if (isNaN(distanciaVerticalCompensada)) {\r\n          console.error(\r\n            `Error: La distancia vertical compensada no es válida para la observación ${obs.id}`\r\n          );\r\n          obs.alturaCompensada = \"NaN\"; // Manejo de error\r\n        } else {\r\n          // Calcular la nueva altura acumulada\r\n          alturaAcumulada += distanciaVerticalCompensada;\r\n\r\n          obs.alturaCompensada = alturaAcumulada.toFixed(4);\r\n          console.log(\r\n            `Altura acumulada y compensada para la observación ${obs.id}: ${obs.alturaCompensada}`\r\n          );\r\n        }\r\n      }\r\n\r\n      return obs;\r\n    });\r\n\r\n    return nuevasObservaciones;\r\n  };\r\n\r\n  const compensarProyeccionesYAlturas = (\r\n    nuevasObservaciones,\r\n    alturaInicial\r\n  ) => {\r\n    const errorNorte = totalProyeccionNorte; // Error en la proyección Norte\r\n    const errorEste = totalProyeccionEste; // Error en la proyección Este\r\n    const errorAlturas = cierreAlturas; // Error de cierre en alturas\r\n\r\n    // Filtrar la primera observación si el brazo es externo\r\n    const observacionesACompensar = brazoExterno\r\n      ? nuevasObservaciones.slice(1)\r\n      : nuevasObservaciones;\r\n\r\n    // Calcular el total de distancia solo de las observaciones que se van a compensar\r\n    const totalDistancia = observacionesACompensar.reduce(\r\n      (total, obs) => total + parseFloat(obs.distancia),\r\n      0\r\n    );\r\n\r\n    // Compensar las distancias verticales antes de ajustar las alturas\r\n    const observacionesConDistanciaCompensada = nuevasObservaciones.map(\r\n      (obs, index) => {\r\n        if (index === 0) {\r\n          return obs; // No compensar la primera observación si es brazo externo\r\n        }\r\n\r\n        // Calcular el ajuste de altura basado en la distancia\r\n        const ajusteAltura =\r\n          (Math.abs(errorAlturas) * obs.distancia) / totalDistancia;\r\n\r\n        // Validar la distancia vertical original\r\n        const distanciaVertical = parseFloat(obs.alturaCalculada1);\r\n        console.log(\r\n          `Distancia Vertical Original para observación ${obs.id}: ${distanciaVertical}`\r\n        );\r\n\r\n        if (isNaN(distanciaVertical)) {\r\n          console.error(\"Error: distanciaVertical no es un número válido\", obs);\r\n          obs.distanciaVerticalCompensada = \"NaN\";\r\n        } else {\r\n          // Ajustar según el signo del errorAlturas\r\n          const distanciaVerticalCompensada =\r\n            errorAlturas < 0\r\n              ? distanciaVertical + ajusteAltura // Sumar si errorAlturas es negativo\r\n              : distanciaVertical - ajusteAltura; // Restar si errorAlturas es positivo\r\n\r\n          console.log(\r\n            `Distancia Vertical Compensada para observación ${obs.id}: ${distanciaVerticalCompensada}`\r\n          );\r\n          obs.distanciaVerticalCompensada =\r\n            distanciaVerticalCompensada.toFixed(4); // Guardar la distancia vertical compensada\r\n        }\r\n\r\n        return obs;\r\n      }\r\n    );\r\n\r\n    // *** Ajustar las alturas verticales con la distancia compensada ***\r\n    const observacionesConAlturasAjustadas = ajustarAlturasVerticales(\r\n      observacionesConDistanciaCompensada,\r\n      alturaInicial\r\n    );\r\n\r\n    // Compensar proyecciones Norte y Este, además de ajustar las alturas calculadas\r\n    const observacionesFinales = observacionesConAlturasAjustadas.map(\r\n      (obs, index) => {\r\n        if (index === 0 && brazoExterno) {\r\n          // Si es la primera observación y el brazo es externo, no se ajusta pero se mantiene en la tabla\r\n          return {\r\n            ...obs,\r\n            proyeccionNorteCompensada: obs.proyeccionNorte,\r\n            proyeccionEsteCompensada: obs.proyeccionEste,\r\n            alturaCompensada: obs.alturaCompensada, // Mantener la altura calculada\r\n          };\r\n        }\r\n\r\n        // Aplicar ajustes a las proyecciones para el resto de las observaciones\r\n        const ajusteNorte = (errorNorte * obs.distancia) / totalDistancia;\r\n        const ajusteEste = (errorEste * obs.distancia) / totalDistancia;\r\n\r\n        const proyeccionNorteCompensada =\r\n          parseFloat(obs.proyeccionNorte) - ajusteNorte;\r\n        const proyeccionEsteCompensada =\r\n          parseFloat(obs.proyeccionEste) - ajusteEste;\r\n\r\n        return {\r\n          ...obs,\r\n          proyeccionNorteCompensada: proyeccionNorteCompensada.toFixed(4),\r\n          proyeccionEsteCompensada: proyeccionEsteCompensada.toFixed(4),\r\n          alturaCompensada: obs.alturaCompensada, // Mantener la altura compensada calculada\r\n        };\r\n      }\r\n    );\r\n\r\n    return observacionesFinales; // Retornar las observaciones compensadas con proyecciones y alturas ajustadas\r\n  };\r\n\r\n  const compensarPoligonal = () => {\r\n    const nuevasObservaciones = compensarAngular(); // Primero ajusta los ángulos\r\n\r\n    // Llama a la función de compensar proyecciones y alturas, incluyendo la altura inicial\r\n    const observacionesFinales = compensarProyeccionesYAlturas(\r\n      nuevasObservaciones,\r\n      alturaInicial // Asegúrate de que alturaInicial esté definida en tu estado o variable\r\n    );\r\n\r\n    setObservacionesCompensadas(observacionesFinales); // Actualizar el estado con las observaciones compensadas\r\n  };\r\n\r\n  // Función para recalcular las coordenadas con las proyecciones ajustadas\r\n  const recalcularCoordenadasAjustadas = (\r\n    norteAnterior,\r\n    esteAnterior,\r\n    proyeccionNorteAjustada,\r\n    proyeccionEsteAjustada\r\n  ) => {\r\n    const nuevoNorteAjustado =\r\n      parseFloat(norteAnterior) + parseFloat(proyeccionNorteAjustada);\r\n    const nuevoEsteAjustado =\r\n      parseFloat(esteAnterior) + parseFloat(proyeccionEsteAjustada);\r\n\r\n    return {\r\n      nuevoNorteAjustado: nuevoNorteAjustado.toFixed(4),\r\n      nuevoEsteAjustado: nuevoEsteAjustado.toFixed(4),\r\n    };\r\n  };\r\n\r\n  return (\r\n    <form\r\n      onSubmit={(e) => e.preventDefault()}\r\n      className=\"formulario-observacion\"\r\n    >\r\n      {!coordenadasCalculadas ? (\r\n        <>\r\n          {\" \"}\r\n          <div>\r\n            <label>Sentido de la Poligonal: </label>\r\n            <select\r\n              value={sentidoPoligonal}\r\n              onChange={(e) => setSentidoPoligonal(e.target.value)}\r\n            >\r\n              <option value=\"internos\">Ángulos Internos</option>\r\n              <option value=\"externos\">Ángulos Externos</option>\r\n            </select>\r\n          </div>\r\n          <div>\r\n            <label>Tipo de Brazo de la Poligonal: </label>\r\n            <select\r\n              value={brazoExterno ? \"externo\" : \"interno\"} // Determinar si el brazo es externo o interno\r\n              onChange={(e) => setBrazoExterno(e.target.value === \"externo\")}\r\n            >\r\n              <option value=\"interno\">Brazo Interno</option>{\" \"}\r\n              {/* Opción para poligonal interna */}\r\n              <option value=\"externo\">Brazo Externo</option>{\" \"}\r\n              {/* Opción para poligonal con brazo externo */}\r\n            </select>\r\n          </div>\r\n          <h3>Coordenadas del Punto Inicial (D1)</h3>\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Norte (Y)\"\r\n            value={norteInicial}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setNorteInicial(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Este (X)\"\r\n            value={esteInicial}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setEsteInicial(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          {/* Nuevo input para la altura inicial */}\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Altura (m)\"\r\n            value={alturaInicial}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setAlturaInicial(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <h3>Coordenadas del Punto Visado (D2)</h3>\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Norte (Y)\"\r\n            value={norteVisado}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setNorteVisado(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Este (X)\"\r\n            value={esteVisado}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setEsteVisado(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <button type=\"button\" onClick={calcularAzimutYAlmacenarValores}>\r\n            Calcular Azimut y Distancia\r\n          </button>\r\n        </>\r\n      ) : (\r\n        <>\r\n          <h3 style={{ margin: \"5px 0\" }}>\r\n            Azimut Inicial: {convertirDecimalAGMS(azimutInicial)}\r\n          </h3>\r\n          <h3 style={{ margin: \"5px 0\" }}>\r\n            Distancia Inicial: {distanciaInicial} metros\r\n          </h3>\r\n          <h3 className=\"header\">Ingresar Observación</h3>\r\n          <div className=\"row-container\">\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">ID Obs</h4>\r\n              <input\r\n                type=\"text\"\r\n                placeholder=\"ID\"\r\n                value={idObservacion}\r\n                onChange={(e) => setIdObservacion(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Ángulo Horizontal</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Grados\"\r\n                value={gradosH}\r\n                onChange={(e) => setGradosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Minutos\"\r\n                value={minutosH}\r\n                onChange={(e) => setMinutosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Segundos\"\r\n                value={segundosH}\r\n                onChange={(e) => setSegundosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Ángulo Vertical</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Grados\"\r\n                value={gradosV}\r\n                onChange={(e) => setGradosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Minutos\"\r\n                value={minutosV}\r\n                onChange={(e) => setMinutosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Segundos\"\r\n                value={segundosV}\r\n                onChange={(e) => setSegundosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Distancia (Metros)</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Distancia (m)\"\r\n                value={distanciaObservada}\r\n                onChange={(e) => setDistanciaObservada(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Altura Instrumental</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Altura Instrumental (m)\"\r\n                value={alturaInstrumental}\r\n                onChange={(e) => setAlturaInstrumental(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Altura Prisma</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Altura Prisma (m)\"\r\n                value={alturaPrisma}\r\n                onChange={(e) => setAlturaPrisma(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n          </div>\r\n          <button type=\"button\" onClick={agregarNuevaObservacion}>\r\n            Agregar Observación\r\n          </button>\r\n          {/* Mostrar el nuevo azimut calculado si está disponible */}\r\n          {nuevoAzimut && (\r\n            <h3>Nuevo Azimut: {convertirDecimalAGMS(nuevoAzimut)}</h3>\r\n          )}\r\n          {/* Tabla de observaciones */}\r\n          {observaciones.length > 0 && (\r\n            <>\r\n              {/* Primera tabla */}\r\n              <table border=\"1\" cellPadding=\"10\" cellSpacing=\"1\">\r\n                <thead>\r\n                  <tr>\r\n                    <th className=\"id\">ID</th>\r\n                    <th className=\"angulo\">Ángulo H</th>\r\n                    <th className=\"angulo\">Ángulo V</th>\r\n                    <th className=\"distancia\">Distancia</th>\r\n                    <th className=\"angulo\">Azimut</th>\r\n                    <th className=\"altura\">Alt Ins</th>\r\n                    <th className=\"altura\">Alt Pri</th>\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {observaciones.map((obs, index) => (\r\n                    <tr key={index}>\r\n                      <td>{obs.id}</td>\r\n                      <td>{obs.anguloHorizontal}</td>\r\n                      <td>{obs.anguloVertical}</td>\r\n                      <td>{obs.distancia}m</td>\r\n                      <td>{obs.azimut}</td>\r\n                      <td>{obs.alturaInstrumental}m</td>\r\n                      <td>{obs.alturaPrisma}m</td>\r\n                    </tr>\r\n                  ))}\r\n                </tbody>\r\n              </table>\r\n              <br /> {/* Espacio entre las dos tablas */}\r\n              {/* Segunda tabla */}\r\n              <table border=\"1\" cellPadding=\"10\" cellSpacing=\"1\">\r\n                <thead>\r\n                  <tr>\r\n                    <th className=\"id\">ID</th> {/* Agregar la columna ID */}\r\n                    <th className=\"proyeccion\">Proy Norte</th>\r\n                    <th className=\"proyeccion\">Proy Este</th>\r\n                    <th className=\"coordenada\">Norte</th>\r\n                    <th className=\"coordenada\">Este</th>\r\n                    <th className=\"altura\">Altura</th> {/* Nueva columna */}\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {observaciones.map((obs, index) => {\r\n                    // Calcular la distancia vertical zenital\r\n                    const distanciaVertical = calcularDistanciaVerticalZenital(\r\n                      obs.gradosV,\r\n                      obs.minutosV,\r\n                      obs.segundosV,\r\n                      obs.distancia\r\n                    );\r\n\r\n                    // Calcular la altura ajustada sobre el piso\r\n                    const alturaCalculada = calcularAlturaObservacion(\r\n                      index === 0\r\n                        ? alturaInicial\r\n                        : observaciones[index - 1].alturaCalculada,\r\n                      distanciaVertical,\r\n                      obs.alturaInstrumental,\r\n                      obs.alturaPrisma\r\n                    );\r\n\r\n                    // Guardar la altura calculada en el objeto de observación\r\n                    observaciones[index].alturaCalculada = alturaCalculada;\r\n\r\n                    return (\r\n                      <tr key={index}>\r\n                        <td>{obs.id}</td> {/* Mostrar el ID */}\r\n                        <td>{obs.proyeccionNorte}m</td>\r\n                        <td>{obs.proyeccionEste}m</td>\r\n                        <td>{obs.nuevoNorte}</td>\r\n                        <td>{obs.nuevoEste}</td>\r\n                        <td>{alturaCalculada}</td>{\" \"}\r\n                        {/* Mostrar la altura calculada */}\r\n                      </tr>\r\n                    );\r\n                  })}\r\n                </tbody>\r\n              </table>\r\n              {/* Botón para borrar la última observación */}\r\n              <button type=\"button\" onClick={borrarUltimaObservacion}>\r\n                Borrar Última Observación\r\n              </button>\r\n              <>\r\n                {/* Resumen Angular de la Poligonal */}\r\n                <div className=\"resumen-angular\">\r\n                  <h3>Resumen Angular de la Poligonal</h3>\r\n                  <p>\r\n                    <strong>Suma Teórica:</strong>{\" \"}\r\n                    {`${sumaTeorica.grados}° ${sumaTeorica.minutos}' ${sumaTeorica.segundos}\"`}\r\n                  </p>\r\n                  <p>\r\n                    <strong>Suma Real:</strong>{\" \"}\r\n                    {`${sumaReal.grados}° ${sumaReal.minutos}' ${sumaReal.segundos}\"`}\r\n                  </p>\r\n                  <p>\r\n                    <strong>Error Angular:</strong>{\" \"}\r\n                    {`${errorAngular.grados}° ${errorAngular.minutos}' ${errorAngular.segundos}\"`}\r\n                  </p>\r\n                </div>\r\n\r\n                {/* Totales */}\r\n                <div className=\"totales\">\r\n                  <h3>Totales</h3>\r\n                  <p>\r\n                    <strong>Total Distancia:</strong>{\" \"}\r\n                    {totalDistancia.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Total Proyección Norte:</strong>{\" \"}\r\n                    {totalProyeccionNorte.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Total Proyección Este:</strong>{\" \"}\r\n                    {totalProyeccionEste.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Cierre Alturas:</strong> {cierreAlturas} m\r\n                  </p>\r\n                </div>\r\n\r\n                {/* Precisión de la Poligonal */}\r\n                <div className=\"precision-poligonal\">\r\n                  <h3>Precisión de la Poligonal</h3>\r\n                  <p>\r\n                    <strong>Precisión:</strong> {precisionPoligonal}\r\n                  </p>\r\n                </div>\r\n              </>\r\n            </>\r\n          )}\r\n          {/* Botón para compensar la poligonal */}\r\n          <button type=\"button\" onClick={compensarPoligonal}>\r\n            Compensar Poligonal\r\n          </button>\r\n          {/* Primera tabla */}\r\n          <table border=\"1\">\r\n            <thead>\r\n              <tr>\r\n                <th>ID</th>\r\n                <th>Ángulo H Compensado</th>\r\n                <th>Proyección N Compensada</th>\r\n                <th>Proyección E Compensada</th>\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {observacionesCompensadas.map((obs, index) => (\r\n                <tr key={index}>\r\n                  <td>{obs.id}</td>\r\n                  <td>{obs.anguloHorizontalCompensado}</td>\r\n                  <td>{obs.proyeccionNorteCompensada}m</td>\r\n                  <td>{obs.proyeccionEsteCompensada}m</td>\r\n                </tr>\r\n              ))}\r\n            </tbody>\r\n          </table>\r\n          <br /> {/* Espacio entre las dos tablas */}\r\n          {/* Segunda tabla */}\r\n          <table border=\"1\">\r\n            <thead>\r\n              <tr>\r\n                <th>ID</th> {/* Agregamos la columna ID en la segunda tabla */}\r\n                <th>Norte Ajustado</th>\r\n                <th>Este Ajustado</th>\r\n                <th>Altura Compensada</th>\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {observacionesCompensadas.map((obs, index) => {\r\n                // Recalcular las coordenadas ajustadas con las proyecciones compensadas\r\n                const { nuevoNorteAjustado, nuevoEsteAjustado } =\r\n                  recalcularCoordenadasAjustadas(\r\n                    index === 0\r\n                      ? norteInicial // Coordenada inicial para la primera observación\r\n                      : observacionesCompensadas[index - 1].nuevoNorteAjustado, // Coordenada anterior para las demás\r\n                    index === 0\r\n                      ? esteInicial\r\n                      : observacionesCompensadas[index - 1].nuevoEsteAjustado,\r\n                    obs.proyeccionNorteCompensada,\r\n                    obs.proyeccionEsteCompensada\r\n                  );\r\n\r\n                // Actualizamos las coordenadas ajustadas en el objeto de observación compensada\r\n                observacionesCompensadas[index].nuevoNorteAjustado =\r\n                  nuevoNorteAjustado;\r\n                observacionesCompensadas[index].nuevoEsteAjustado =\r\n                  nuevoEsteAjustado;\r\n\r\n                return (\r\n                  <tr key={index}>\r\n                    <td>{obs.id}</td> {/* Mostrar ID en la segunda tabla */}\r\n                    <td>{nuevoNorteAjustado}</td>\r\n                    <td>{nuevoEsteAjustado}</td>\r\n                    <td>\r\n                      {isNaN(parseFloat(obs.alturaCompensada))\r\n                        ? \"-\"\r\n                        : parseFloat(obs.alturaCompensada).toFixed(3)}\r\n                    </td>\r\n                  </tr>\r\n                );\r\n              })}\r\n            </tbody>\r\n          </table>\r\n          {/* Tabla de observaciones compensadas */}\r\n          {observacionesCompensadas.length > 0 && (\r\n            <>\r\n              <h3>Observaciones Compensadas</h3>\r\n\r\n              {/* Añadir el gráfico aquí */}\r\n\r\n              <div className=\"app-container\">\r\n                <GraficoPoligonal\r\n                  observacionesCompensadas={observacionesCompensadas}\r\n                />\r\n              </div>\r\n            </>\r\n          )}\r\n        </>\r\n      )}\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default FormularioObservacion;\r\n","import React, { useState } from \"react\";\nimport FormularioObservacion from \"./components/FormularioObservacion\";\n\nimport \"./App.css\";\n\nfunction App() {\n  const [observaciones, setObservaciones] = useState([]);\n\n  const agregarObservacion = (observacion) => {\n    setObservaciones([...observaciones, observacion]);\n  };\n\n  return (\n    <div className=\"App\">\n      <h1>Cálculo de Poligonales</h1>\n      <FormularioObservacion agregarObservacion={agregarObservacion} />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}