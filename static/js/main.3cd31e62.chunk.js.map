{"version":3,"sources":["components/GraficoPoligonalSVG.js","components/FormularioObservacion.js","App.js","reportWebVitals.js","index.js"],"names":["GraficoPoligonal","_ref","observacionesCompensadas","colorLinea","setColorLinea","useState","grosorLinea","setGrosorLinea","colorPunto","setColorPunto","tamañoFlecha","setTamañoFlecha","colorFlecha","setColorFlecha","mostrarFlecha","setMostrarFlecha","minX","Math","min","map","p","parseFloat","nuevoEsteAjustado","maxX","max","minY","nuevoNorteAjustado","maxY","rangoX","rangoY","escala","offsetX","offsetY","escalarX","valor","escalarY","React","createElement","style","position","border","width","height","padding","top","left","backgroundColor","borderRadius","boxShadow","zIndex","fontSize","display","marginBottom","type","value","onChange","e","target","marginTop","Number","checked","UncontrolledReactSVGPanZoom","background","tool","detectAutoPan","toolbarProps","id","markerWidth","markerHeight","refX","refY","orient","markerUnits","d","fill","Array","from","length","anchoSVG","_","i","key","x1","y1","x2","y2","stroke","strokeWidth","altoSVG","index","cx","cy","r","data-tooltip-id","data-tooltip-content","cursor","x","y","ReactTooltip","place","effect","markerEnd","FormularioObservacion","agregarObservacion","norteInicial","setNorteInicial","esteInicial","setEsteInicial","norteVisado","setNorteVisado","esteVisado","setEsteVisado","azimutInicial","setAzimutInicial","distanciaInicial","setDistanciaInicial","coordenadasCalculadas","setCoordenadasCalculadas","gradosH","setGradosH","minutosH","setMinutosH","segundosH","setSegundosH","gradosV","setGradosV","minutosV","setMinutosV","segundosV","setSegundosV","distanciaObservada","setDistanciaObservada","alturaInicial","setAlturaInicial","nuevoAzimut","setNuevoAzimut","sumaTeorica","setSumaTeorica","sumaReal","setSumaReal","errorAngular","setErrorAngular","sentidoPoligonal","setSentidoPoligonal","setObservacionesCompensadas","brazoExterno","setBrazoExterno","cierreAlturas","setCierreAlturas","calcularCierreAlturas","observacionesActualizadas","sumatoriaDistanciasVerticales","slice","reduce","acumulado","obs","distanciaVertical","alturaInstrumental","alturaPrisma","console","log","toFixed","calcularCierreAngular","observaciones","N","grados","minutos","segundos","contadorObservaciones","sumatoriaInicializada","forEach","angulo","sumarAngulos","restarAngulos","a1","a2","floor","convertirAGradosDecimales","mayor","menor","convertirGMSToDecimal","convertirDecimalAGMS","gradosDecimales","minutosDecimales","round","setObservaciones","setAlturaInstrumental","setAlturaPrisma","precisionPoligonal","setPrecisionPoligonal","idObservacion","setIdObservacion","calcularDistanciaVerticalZenital","anguloDecimal","anguloRad","convertirGradosARadianes","cos","calcularAlturaObservacion","PI","calcularCoordenadas","norteAnterior","esteAnterior","proyeccionNorte","proyeccionEste","nuevoNorte","nuevoEste","setContadorObservaciones","totalDistancia","setTotalDistancia","totalProyeccionNorte","setTotalProyeccionNorte","totalProyeccionEste","setTotalProyeccionEste","ultimoAzimut","setUltimoAzimut","calcularPrecision","distanciaTotal","proyeccionNorteTotal","proyeccionEsteTotal","sqrt","pow","calcularContraAzimut","azimut","contraAzimut","calcularAzimutSegundaObservacion","anguloObservadoDecimal","compensarProyeccionesYAlturas","nuevasObservaciones","errorNorte","errorEste","errorAlturas","total","distancia","alturaAcumulada","alturaCalculada","isNaN","error","alturaCompensada","distanciaVerticalCompensada","ajustarAlturasVerticales","ajusteAltura","abs","alturaCalculada1","proyeccionNorteCompensada","proyeccionEsteCompensada","ajusteNorte","ajusteEste","onSubmit","preventDefault","className","Fragment","margin","placeholder","onClick","agregarNuevaObservacion","undefined","alert","nuevoAzimutCalculado","calcularAzimutObservacion","anguloHorizontalDecimal","calcularNuevoAzimut","azimutSexagesimal","norte","este","calcularProyecciones","azimutRad","sin","nuevaObservacion","anguloHorizontal","anguloVertical","prevObservaciones","observacionesFiltradas","nuevasDistancias","acc","nuevasProyeccionesNorte","nuevasProyeccionesEste","nuevaPrecision","recalcularTotales","prevTotal","cellPadding","cellSpacing","borrarUltimaObservacion","ultimaObservacion","ultimoAzimutAnterior","ultimoAzimutDecimal","split","num","compensarPoligonal","compensarAngular","cantidadObservaciones","ajusteAngular","anguloHorizontalCompensado","anguloDec","anguloCompensadoGMS","observacionesFinales","recalcularCoordenadasAjustadas","proyeccionNorteAjustada","proyeccionEsteAjustada","GraficoPoligonalSVG","required","clas","sName","calcularAzimutYAlmacenarValores","calcularAzimutYDistanciaDesdeCoordenadas","deltaX","deltaY","azimutDeg","atan2","App","observacion","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.3cd31e62.chunk.js","sourcesContent":["import React, { useState } from \"react\";\r\nimport ReactTooltip from \"react-tooltip\";\r\nimport { UncontrolledReactSVGPanZoom } from \"react-svg-pan-zoom\"; // Pan y zoom para el SVG\r\n\r\nconst GraficoPoligonal = ({ observacionesCompensadas = [] }) => {\r\n  const [colorLinea, setColorLinea] = useState(\"blue\");\r\n  const [grosorLinea, setGrosorLinea] = useState(2);\r\n  const [colorPunto, setColorPunto] = useState(\"red\");\r\n  const [tamañoFlecha, setTamañoFlecha] = useState(10);\r\n  const [colorFlecha, setColorFlecha] = useState(\"blue\");\r\n  const [mostrarFlecha, setMostrarFlecha] = useState(true);\r\n\r\n  const anchoSVG = 550;\r\n  const altoSVG = 550;\r\n  const gridSpacing = 100; // Espaciado de la cuadrícula\r\n\r\n  // Calcula los valores mínimos y máximos de las coordenadas ajustadas\r\n  const minX = Math.min(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoEsteAjustado))\r\n  );\r\n  const maxX = Math.max(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoEsteAjustado))\r\n  );\r\n  const minY = Math.min(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoNorteAjustado))\r\n  );\r\n  const maxY = Math.max(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoNorteAjustado))\r\n  );\r\n\r\n  // Agrega un margen del 10% alrededor de los extremos\r\n  const margen = 0.1; // 10% de margen\r\n\r\n  const rangoX = (maxX - minX) * (1 + margen);\r\n  const rangoY = (maxY - minY) * (1 + margen);\r\n\r\n  // Calcula la escala para ajustar la poligonal al tamaño del SVG\r\n  const escala = Math.min(anchoSVG / rangoX, altoSVG / rangoY);\r\n\r\n  // Centra la poligonal en el SVG\r\n  const offsetX = (anchoSVG - (maxX - minX) * escala) / 2;\r\n  const offsetY = (altoSVG - (maxY - minY) * escala) / 2;\r\n\r\n  // Función para escalar las coordenadas al tamaño del SVG\r\n  const escalarX = (valor) => (valor - minX) * escala + offsetX;\r\n  const escalarY = (valor) => altoSVG - (valor - minY) * escala - offsetY; // Invertir el eje Y para el SVG\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        position: \"relative\",\r\n        border: \"2px solid black\",\r\n        width: `${anchoSVG}px`,\r\n        height: `${altoSVG}px`,\r\n        padding: \"10px\",\r\n      }}\r\n    >\r\n      {/* Controles flotantes, más compactos */}\r\n      <div\r\n        style={{\r\n          position: \"absolute\",\r\n          top: \"5px\",\r\n          left: \"5px\",\r\n          backgroundColor: \"transparent\",\r\n          padding: \"5px\",\r\n          borderRadius: \"8px\",\r\n          boxShadow: \"0px 4px 10px rgba(0, 0, 0, 0.1)\",\r\n          zIndex: 10, // Asegura que esté encima del SVG\r\n          fontSize: \"10px\", // Hacer más pequeños los controles\r\n        }}\r\n      >\r\n        <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n          Color de la línea:\r\n          <input\r\n            type=\"color\"\r\n            value={colorLinea}\r\n            onChange={(e) => setColorLinea(e.target.value)}\r\n            style={{ width: \"40%\", marginTop: \"3px\" }}\r\n          />\r\n        </label>\r\n        <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n          Grosor de la línea:\r\n          <input\r\n            type=\"number\"\r\n            min=\"1\"\r\n            max=\"50\"\r\n            value={grosorLinea}\r\n            onChange={(e) => setGrosorLinea(Number(e.target.value))}\r\n            style={{ width: \"30%\", marginTop: \"3px\" }}\r\n          />\r\n        </label>\r\n        <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n          Color del punto:\r\n          <input\r\n            type=\"color\"\r\n            value={colorPunto}\r\n            onChange={(e) => setColorPunto(e.target.value)}\r\n            style={{ width: \"40%\", marginTop: \"3px\" }}\r\n          />\r\n        </label>\r\n        <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n          Tamaño de la flecha:\r\n          <input\r\n            type=\"number\"\r\n            min=\"5\"\r\n            max=\"40\"\r\n            value={tamañoFlecha}\r\n            onChange={(e) => setTamañoFlecha(Number(e.target.value))}\r\n            style={{ width: \"30%\", marginTop: \"2px\" }}\r\n          />\r\n        </label>\r\n        <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n          Color de la flecha:\r\n          <input\r\n            type=\"color\"\r\n            value={colorFlecha}\r\n            onChange={(e) => setColorFlecha(e.target.value)}\r\n            style={{ width: \"40%\", marginTop: \"3px\" }}\r\n          />\r\n        </label>\r\n        <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n          Mostrar flecha:\r\n          <input\r\n            type=\"checkbox\"\r\n            checked={mostrarFlecha}\r\n            onChange={(e) => setMostrarFlecha(e.target.checked)}\r\n            style={{ marginTop: \"3px\" }}\r\n          />\r\n        </label>\r\n      </div>\r\n\r\n      {/* Renderización del SVG con pan y zoom */}\r\n      <UncontrolledReactSVGPanZoom\r\n        width={anchoSVG}\r\n        height={altoSVG}\r\n        background=\"transparent\"\r\n        tool=\"auto\"\r\n        detectAutoPan={false}\r\n        toolbarProps={{ position: \"none\" }} // Ocultar los botones de la herramienta\r\n      >\r\n        <svg width={anchoSVG} height={altoSVG} style={{ zIndex: 1 }}>\r\n          <defs>\r\n            <marker\r\n              id=\"arrow\"\r\n              markerWidth={tamañoFlecha}\r\n              markerHeight={tamañoFlecha}\r\n              refX=\"10\"\r\n              refY=\"3\"\r\n              orient=\"auto\"\r\n              markerUnits=\"strokeWidth\"\r\n            >\r\n              <path d=\"M0,0 L0,6 L9,3 z\" fill={colorFlecha} />\r\n            </marker>\r\n          </defs>\r\n\r\n          {/* Renderización de la cuadrícula */}\r\n          {/* Líneas verticales */}\r\n          {Array.from({ length: anchoSVG / gridSpacing }).map((_, i) => (\r\n            <line\r\n              key={`v-grid-${i}`}\r\n              x1={i * gridSpacing}\r\n              y1={0}\r\n              x2={i * gridSpacing}\r\n              y2={altoSVG}\r\n              stroke=\"#d3d3d3\"\r\n              strokeWidth=\"1\"\r\n            />\r\n          ))}\r\n\r\n          {/* Líneas horizontales */}\r\n          {Array.from({ length: altoSVG / gridSpacing }).map((_, i) => (\r\n            <line\r\n              key={`h-grid-${i}`}\r\n              x1={0}\r\n              y1={i * gridSpacing}\r\n              x2={anchoSVG}\r\n              y2={i * gridSpacing}\r\n              stroke=\"#d3d3d3\"\r\n              strokeWidth=\"1\"\r\n            />\r\n          ))}\r\n\r\n          {/* Renderización de los puntos escalados y sus IDs */}\r\n          {observacionesCompensadas.map((p, index) => {\r\n            const cx = escalarX(parseFloat(p.nuevoEsteAjustado));\r\n            const cy = escalarY(parseFloat(p.nuevoNorteAjustado));\r\n            return (\r\n              <g key={index}>\r\n                <circle\r\n                  cx={cx}\r\n                  cy={cy}\r\n                  r=\"6\"\r\n                  fill={colorPunto}\r\n                  data-tooltip-id={`tooltip-${index}`} // Asigna un ID al tooltip\r\n                  data-tooltip-content={`ID: ${p.id}, Norte: ${p.nuevoNorteAjustado}, Este: ${p.nuevoEsteAjustado}`} // Contenido del tooltip\r\n                  style={{ cursor: \"pointer\" }} // Cambia el cursor para indicar interactividad\r\n                />\r\n                {/* Texto del ID del punto */}\r\n                <text x={cx + 5} y={cy - 5} fontSize=\"12\" fill=\"black\">\r\n                  {p.id}\r\n                </text>\r\n\r\n                {/* Renderización del Tooltip */}\r\n                <ReactTooltip\r\n                  id={`tooltip-${index}`}\r\n                  place=\"top\"\r\n                  effect=\"solid\"\r\n                />\r\n              </g>\r\n            );\r\n          })}\r\n\r\n          {/* Renderización de las líneas escaladas */}\r\n          {observacionesCompensadas.map((p, index) => {\r\n            if (index < observacionesCompensadas.length - 1) {\r\n              const x1 = escalarX(parseFloat(p.nuevoEsteAjustado));\r\n              const y1 = escalarY(parseFloat(p.nuevoNorteAjustado));\r\n              const x2 = escalarX(\r\n                parseFloat(\r\n                  observacionesCompensadas[index + 1].nuevoEsteAjustado\r\n                )\r\n              );\r\n              const y2 = escalarY(\r\n                parseFloat(\r\n                  observacionesCompensadas[index + 1].nuevoNorteAjustado\r\n                )\r\n              );\r\n              return (\r\n                <line\r\n                  key={index}\r\n                  x1={x1}\r\n                  y1={y1}\r\n                  x2={x2}\r\n                  y2={y2}\r\n                  stroke={colorLinea}\r\n                  strokeWidth={grosorLinea}\r\n                  markerEnd={mostrarFlecha ? \"url(#arrow)\" : null}\r\n                />\r\n              );\r\n            }\r\n            return null;\r\n          })}\r\n\r\n          {/* Agregar la línea para cerrar la poligonal con la flecha invertida */}\r\n          {observacionesCompensadas.length > 2 && (\r\n            <line\r\n              x1={escalarX(\r\n                parseFloat(\r\n                  observacionesCompensadas[observacionesCompensadas.length - 1]\r\n                    .nuevoEsteAjustado\r\n                )\r\n              )}\r\n              y1={escalarY(\r\n                parseFloat(\r\n                  observacionesCompensadas[observacionesCompensadas.length - 1]\r\n                    .nuevoNorteAjustado\r\n                )\r\n              )}\r\n              x2={escalarX(\r\n                parseFloat(observacionesCompensadas[0].nuevoEsteAjustado)\r\n              )}\r\n              y2={escalarY(\r\n                parseFloat(observacionesCompensadas[0].nuevoNorteAjustado)\r\n              )}\r\n              stroke={colorLinea}\r\n              strokeWidth={grosorLinea}\r\n              markerEnd={mostrarFlecha ? \"url(#arrow)\" : null} // Flecha inversa\r\n            />\r\n          )}\r\n        </svg>\r\n      </UncontrolledReactSVGPanZoom>\r\n\r\n      {/* Renderiza los tooltips */}\r\n      {observacionesCompensadas.map((_, index) => (\r\n        <ReactTooltip key={index} id={`tooltip-${index}`} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GraficoPoligonal;\r\n","import React, { useState } from \"react\";\r\nimport GraficoPoligonalSVG from \"./GraficoPoligonalSVG\";\r\n\r\nconst FormularioObservacion = ({ agregarObservacion }) => {\r\n  // Estados para coordenadas y observaciones\r\n  const [norteInicial, setNorteInicial] = useState(\"\");\r\n  const [esteInicial, setEsteInicial] = useState(\"\");\r\n  const [norteVisado, setNorteVisado] = useState(\"\");\r\n  const [esteVisado, setEsteVisado] = useState(\"\");\r\n\r\n  const [azimutInicial, setAzimutInicial] = useState(null); // Estado para el azimut inicial\r\n  const [distanciaInicial, setDistanciaInicial] = useState(null); // Estado para la distancia inicial\r\n  const [coordenadasCalculadas, setCoordenadasCalculadas] = useState(false); // Para controlar si ya calculaste las coordenadas\r\n\r\n  // Estados para los ángulos y la distancia observada\r\n  const [gradosH, setGradosH] = useState(\"\");\r\n  const [minutosH, setMinutosH] = useState(\"\");\r\n  const [segundosH, setSegundosH] = useState(\"\");\r\n\r\n  const [gradosV, setGradosV] = useState(\"\");\r\n  const [minutosV, setMinutosV] = useState(\"\");\r\n  const [segundosV, setSegundosV] = useState(\"\");\r\n\r\n  const [distanciaObservada, setDistanciaObservada] = useState(\"\");\r\n  const [alturaInicial, setAlturaInicial] = useState(\"\"); // Nueva variable para la altura inicial\r\n\r\n  const [nuevoAzimut, setNuevoAzimut] = useState(null); // Estado para el nuevo azimut calculado\r\n\r\n  const [sumaTeorica, setSumaTeorica] = useState(0);\r\n  const [sumaReal, setSumaReal] = useState(0);\r\n  const [errorAngular, setErrorAngular] = useState(0);\r\n\r\n  const [sentidoPoligonal, setSentidoPoligonal] = useState(\"internos\"); // 'internos' o 'externos'\r\n  const [observacionesCompensadas, setObservacionesCompensadas] = useState([]); // Para las observaciones ajustadas\r\n  // Suponiendo que tienes estos estados definidos en algún lugar del componente\r\n  const [brazoExterno, setBrazoExterno] = useState(false); // Por defecto, el brazo es interno\r\n  const [cierreAlturas, setCierreAlturas] = useState(0); // Estado para almacenar el cierre de alturas\r\n\r\n  const calcularCierreAlturas = (observacionesActualizadas) => {\r\n    if (observacionesActualizadas.length === 0) {\r\n      setCierreAlturas(0); // Si no hay observaciones, el cierre de alturas es 0\r\n      return 0;\r\n    }\r\n\r\n    // Filtrar las observaciones según el tipo de brazo\r\n    const observacionesAConsiderar = brazoExterno\r\n      ? observacionesActualizadas.slice(1) // Si es brazo externo, omitimos la primera observación\r\n      : observacionesActualizadas; // Si es brazo interno, usamos todas las observaciones\r\n\r\n    // Calcular la sumatoria de las distancias verticales reales (valor absoluto)\r\n    const sumatoriaDistanciasVerticales = observacionesAConsiderar.reduce(\r\n      (acumulado, obs) =>\r\n        acumulado +\r\n        parseFloat(obs.distanciaVertical) + // Tomamos el valor absoluto de la distancia vertical\r\n        parseFloat(obs.alturaInstrumental) -\r\n        parseFloat(obs.alturaPrisma),\r\n      0\r\n    );\r\n\r\n    console.log(\r\n      `\\nSumatoria de Distancias Verticales Calculadas: ${sumatoriaDistanciasVerticales.toFixed(\r\n        4\r\n      )}`\r\n    );\r\n\r\n    // Guardar y retornar el cierre de alturas manteniendo el signo\r\n    const cierreAlturas = sumatoriaDistanciasVerticales.toFixed(4);\r\n    setCierreAlturas(cierreAlturas);\r\n\r\n    console.log(`Cierre de alturas calculado: ${cierreAlturas}`);\r\n\r\n    return parseFloat(cierreAlturas); // Retornamos el valor numérico con su signo\r\n  };\r\n\r\n  const calcularCierreAngular = (observaciones, sentidoPoligonal) => {\r\n    const N = observaciones.length;\r\n    if (N === 0) return;\r\n\r\n    // Inicializamos la sumatoria de los ángulos con 0° 0' 0\"\r\n    let sumaReal = { grados: 0, minutos: 0, segundos: 0 };\r\n\r\n    // Contador para rastrear el número de observaciones\r\n    let contadorObservaciones = 0;\r\n\r\n    // Bandera para saber si ya hemos inicializado la suma con la segunda observación\r\n    let sumatoriaInicializada = false;\r\n\r\n    // Iteramos sobre las observaciones\r\n    observaciones.forEach((obs) => {\r\n      contadorObservaciones++; // Incrementamos el contador por cada observación\r\n\r\n      // Si es la primera observación y el brazo es externo, la ignoramos\r\n      if (contadorObservaciones === 0 && brazoExterno) {\r\n        return; // Salta la primera observación\r\n      }\r\n\r\n      // Convertir los valores del ángulo de la observación actual\r\n      const angulo = {\r\n        grados: Number(obs.gradosH),\r\n        minutos: Number(obs.minutosH),\r\n        segundos: Number(obs.segundosH),\r\n      };\r\n\r\n      // Si es la segunda observación y la primera fue omitida, inicializamos la sumatoria\r\n      if (\r\n        contadorObservaciones === 0 &&\r\n        brazoExterno &&\r\n        !sumatoriaInicializada\r\n      ) {\r\n        sumaReal = angulo; // Iniciamos la sumatoria con el ángulo de la segunda observación\r\n        sumatoriaInicializada = true; // Marcamos que ya hemos inicializado la sumatoria\r\n      } else {\r\n        // Para todas las demás observaciones, sumamos los ángulos normalmente\r\n        sumaReal = sumarAngulos(sumaReal, angulo);\r\n      }\r\n    });\r\n\r\n    // Calculamos la suma teórica dependiendo del tipo de poligonal\r\n    let sumaTeorica;\r\n    if (sentidoPoligonal === \"internos\") {\r\n      sumaTeorica = { grados: (N - 2) * 180, minutos: 0, segundos: 0 };\r\n    } else {\r\n      sumaTeorica = { grados: (N + 2) * 180, minutos: 0, segundos: 0 };\r\n    }\r\n\r\n    // Calculamos el error angular\r\n    const errorAngular = restarAngulos(sumaTeorica, sumaReal);\r\n\r\n    // Actualizamos los estados con los valores finales\r\n    setSumaTeorica(sumaTeorica);\r\n    setSumaReal(sumaReal);\r\n    setErrorAngular(errorAngular);\r\n  };\r\n\r\n  const sumarAngulos = (a1, a2) => {\r\n    let segundos = Number(a1.segundos) + Number(a2.segundos);\r\n    let minutos = Number(a1.minutos) + Number(a2.minutos);\r\n    let grados = Number(a1.grados) + Number(a2.grados);\r\n\r\n    // Ajustar segundos si exceden 60\r\n    if (segundos >= 60) {\r\n      minutos += Math.floor(segundos / 60);\r\n      segundos = segundos % 60;\r\n    }\r\n\r\n    // Ajustar minutos si exceden 60\r\n    if (minutos >= 60) {\r\n      grados += Math.floor(minutos / 60);\r\n      minutos = minutos % 60;\r\n    }\r\n\r\n    return { grados, minutos, segundos };\r\n  };\r\n\r\n  const convertirAGradosDecimales = (grados, minutos, segundos) => {\r\n    return grados + minutos / 60 + segundos / 3600;\r\n  };\r\n\r\n  const restarAngulos = (a1, a2) => {\r\n    // Convertir los ángulos a grados decimales para compararlos\r\n    const angulo1Decimal = convertirAGradosDecimales(\r\n      a1.grados,\r\n      a1.minutos,\r\n      a1.segundos\r\n    );\r\n    const angulo2Decimal = convertirAGradosDecimales(\r\n      a2.grados,\r\n      a2.minutos,\r\n      a2.segundos\r\n    );\r\n\r\n    // Determinar cuál es el mayor y el menor\r\n    let mayor, menor;\r\n    if (angulo1Decimal >= angulo2Decimal) {\r\n      mayor = a1;\r\n      menor = a2;\r\n    } else {\r\n      mayor = a2;\r\n      menor = a1;\r\n    }\r\n\r\n    // Restar ángulos (siempre mayor - menor)\r\n    let segundos = mayor.segundos - menor.segundos;\r\n    let minutos = mayor.minutos - menor.minutos;\r\n    let grados = mayor.grados - menor.grados;\r\n\r\n    // Si los segundos son negativos, pedir prestado 1 minuto\r\n    if (segundos < 0) {\r\n      segundos += 60;\r\n      minutos -= 1;\r\n    }\r\n\r\n    // Si los minutos son negativos, pedir prestado 1 grado\r\n    if (minutos < 0) {\r\n      minutos += 60;\r\n      grados -= 1;\r\n    }\r\n\r\n    return { grados, minutos, segundos };\r\n  };\r\n\r\n  // Función para convertir GMS a grados decimales\r\n  const convertirGMSToDecimal = (grados, minutos, segundos) => {\r\n    return (\r\n      parseFloat(grados) +\r\n      parseFloat(minutos) / 60 +\r\n      parseFloat(segundos) / 3600\r\n    );\r\n  };\r\n  const convertirDecimalAGMS = (gradosDecimales) => {\r\n    const grados = Math.floor(gradosDecimales); // Parte entera para los grados\r\n    const minutosDecimales = (gradosDecimales - grados) * 60;\r\n    const minutos = Math.floor(minutosDecimales); // Parte entera para los minutos\r\n    const segundos = Math.round((minutosDecimales - minutos) * 60); // Redondear los segundos a enteros\r\n\r\n    return `${grados}° ${minutos}' ${segundos}\"`;\r\n  };\r\n\r\n  // Estado para almacenar todas las observaciones\r\n  const [observaciones, setObservaciones] = useState([]);\r\n\r\n  // Estados para las alturas\r\n  const [alturaInstrumental, setAlturaInstrumental] = useState(\"\");\r\n  const [alturaPrisma, setAlturaPrisma] = useState(\"\");\r\n\r\n  // Estado para almacenar la precisión de la poligonal\r\n  const [precisionPoligonal, setPrecisionPoligonal] = useState(0);\r\n\r\n  // Estado para el ID de la observación\r\n  const [idObservacion, setIdObservacion] = useState(\"\");\r\n\r\n  // Función para calcular el azimut inicial y la distancia a partir de coordenadas\r\n  const calcularAzimutYDistanciaDesdeCoordenadas = (\r\n    norteInicial,\r\n    esteInicial,\r\n    norteVisado,\r\n    esteVisado\r\n  ) => {\r\n    const deltaX = parseFloat(esteVisado) - parseFloat(esteInicial);\r\n    const deltaY = parseFloat(norteVisado) - parseFloat(norteInicial);\r\n\r\n    // Azimut inicial en grados\r\n    let azimutRad = Math.atan2(deltaX, deltaY);\r\n    let azimutDeg = azimutRad * (180 / Math.PI); // Convertimos de radianes a grados\r\n\r\n    // Ajustar el azimut para que esté en el rango de 0 a 360 grados\r\n    if (azimutDeg < 0) {\r\n      azimutDeg += 360;\r\n    } else if (azimutDeg >= 360) {\r\n      azimutDeg -= 360;\r\n    }\r\n\r\n    // Calcular la distancia entre D1 y D2\r\n    const distancia = Math.sqrt(deltaX ** 2 + deltaY ** 2);\r\n\r\n    // Retornar el azimut y la distancia\r\n    return {\r\n      azimut: azimutDeg.toFixed(4), // Redondear azimut a 4 decimales\r\n      distancia: distancia.toFixed(4), // Redondear distancia a 4 decimales\r\n    };\r\n  };\r\n\r\n  // Función que calcula y almacena azimut y distancia\r\n  const calcularAzimutYAlmacenarValores = () => {\r\n    const { azimut, distancia } = calcularAzimutYDistanciaDesdeCoordenadas(\r\n      norteInicial,\r\n      esteInicial,\r\n      norteVisado,\r\n      esteVisado\r\n    );\r\n\r\n    // Almacenar los valores calculados en el estado\r\n    setAzimutInicial(azimut);\r\n    setDistanciaInicial(distancia);\r\n\r\n    setCoordenadasCalculadas(true); // Cambiar el estado para ocultar los inputs de coordenadas si corresponde\r\n  };\r\n\r\n  // Función para calcular la distancia vertical zenital\r\n  const calcularDistanciaVerticalZenital = (\r\n    grados,\r\n    minutos,\r\n    segundos,\r\n    distanciaObservada\r\n  ) => {\r\n    // Convertimos los grados a decimales\r\n    const anguloDecimal = convertirGMSToDecimal(grados, minutos, segundos);\r\n\r\n    // Convertimos el ángulo a radianes\r\n    const anguloRad = convertirGradosARadianes(anguloDecimal);\r\n\r\n    // Calculamos la distancia vertical usando el coseno del ángulo\r\n    const distanciaVertical = distanciaObservada * Math.cos(anguloRad);\r\n\r\n    return distanciaVertical.toFixed(4); // Redondear a 4 decimales\r\n  };\r\n\r\n  const calcularAlturaObservacion = (\r\n    alturaInicial,\r\n    distanciaVertical,\r\n    alturaInstrumental,\r\n    alturaPrisma\r\n  ) => {\r\n    // Calcular la altura final sobre el piso\r\n    const alturaFinal =\r\n      parseFloat(alturaInicial) +\r\n      parseFloat(alturaInstrumental) -\r\n      parseFloat(alturaPrisma) +\r\n      parseFloat(distanciaVertical);\r\n    return alturaFinal.toFixed(4); // Redondear a 4 decimales\r\n  };\r\n\r\n  // Función para calcular el nuevo azimut basado en el azimut inicial y el ángulo observado\r\n  const calcularNuevoAzimut = (azimutInicial, anguloObservadoDecimal) => {\r\n    let nuevoAzimut = azimutInicial + anguloObservadoDecimal;\r\n\r\n    // Si el azimut es mayor o igual a 360, restamos 360 para ajustarlo\r\n    if (nuevoAzimut >= 360) {\r\n      nuevoAzimut -= 360;\r\n    }\r\n\r\n    return nuevoAzimut.toFixed(4); // Retornamos el nuevo azimut en grados decimales\r\n  };\r\n\r\n  // Función para calcular y almacenar el nuevo azimut basado en la observación\r\n  const calcularAzimutObservacion = () => {\r\n    // Convertir ángulo observado (horizontal) a grados decimales\r\n    const anguloHorizontalDecimal = convertirGMSToDecimal(\r\n      gradosH,\r\n      minutosH,\r\n      segundosH\r\n    );\r\n\r\n    // Calcular el nuevo azimut basado en el ángulo observado y el azimut inicial\r\n    const nuevoAzimutCalculado = calcularNuevoAzimut(\r\n      parseFloat(azimutInicial),\r\n      anguloHorizontalDecimal\r\n    );\r\n\r\n    // Guardar el nuevo azimut en el estado\r\n    setNuevoAzimut(nuevoAzimutCalculado);\r\n\r\n    return nuevoAzimutCalculado;\r\n  };\r\n\r\n  // Función para convertir grados a radianes\r\n  const convertirGradosARadianes = (grados) => {\r\n    return (grados * Math.PI) / 180;\r\n  };\r\n\r\n  // Función para calcular las proyecciones Norte y Este\r\n  const calcularProyecciones = (azimut, distancia) => {\r\n    const azimutRad = convertirGradosARadianes(azimut); // Convertir el azimut a radianes\r\n\r\n    // Proyección Norte (coseno del azimut por la distancia)\r\n    const proyeccionNorte = Math.cos(azimutRad) * distancia;\r\n\r\n    // Proyección Este (seno del azimut por la distancia)\r\n    const proyeccionEste = Math.sin(azimutRad) * distancia;\r\n\r\n    // Retornamos las proyecciones redondeadas a 4 decimales\r\n    return {\r\n      norte: proyeccionNorte.toFixed(4),\r\n      este: proyeccionEste.toFixed(4),\r\n    };\r\n  };\r\n\r\n  // Función para calcular las nuevas coordenadas\r\n  const calcularCoordenadas = (\r\n    norteAnterior,\r\n    esteAnterior,\r\n    proyeccionNorte,\r\n    proyeccionEste\r\n  ) => {\r\n    const nuevoNorte = parseFloat(norteAnterior) + parseFloat(proyeccionNorte);\r\n    const nuevoEste = parseFloat(esteAnterior) + parseFloat(proyeccionEste);\r\n\r\n    return {\r\n      nuevoNorte: nuevoNorte.toFixed(4), // Redondear a 4 decimales\r\n      nuevoEste: nuevoEste.toFixed(4), // Redondear a 4 decimales\r\n    };\r\n  };\r\n  const [contadorObservaciones, setContadorObservaciones] = useState(0); // Contador para saber cuántas observaciones se han hecho\r\n  // Estados para los totales\r\n  const [totalDistancia, setTotalDistancia] = useState(0);\r\n  const [totalProyeccionNorte, setTotalProyeccionNorte] = useState(0);\r\n  const [totalProyeccionEste, setTotalProyeccionEste] = useState(0);\r\n\r\n  // Estado para almacenar el último azimut calculado (usado para las siguientes observaciones)\r\n  const [ultimoAzimut, setUltimoAzimut] = useState(null);\r\n\r\n  const recalcularTotales = (nuevasObservaciones) => {\r\n    // Filtrar la primera observación si el brazo es externo\r\n    const observacionesFiltradas = brazoExterno\r\n      ? nuevasObservaciones.slice(1)\r\n      : nuevasObservaciones;\r\n\r\n    calcularCierreAngular(observacionesFiltradas, sentidoPoligonal);\r\n    calcularCierreAlturas(observacionesFiltradas, alturaInicial);\r\n\r\n    const nuevasDistancias = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.distancia),\r\n      0\r\n    );\r\n\r\n    const nuevasProyeccionesNorte = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.proyeccionNorte),\r\n      0\r\n    );\r\n    const nuevasProyeccionesEste = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.proyeccionEste),\r\n      0\r\n    );\r\n\r\n    setTotalDistancia(nuevasDistancias);\r\n    setTotalProyeccionNorte(nuevasProyeccionesNorte);\r\n    setTotalProyeccionEste(nuevasProyeccionesEste);\r\n\r\n    const nuevaPrecision = calcularPrecision(\r\n      nuevasDistancias,\r\n      nuevasProyeccionesNorte,\r\n      nuevasProyeccionesEste\r\n    );\r\n    setPrecisionPoligonal(nuevaPrecision);\r\n  };\r\n\r\n  const agregarNuevaObservacion = () => {\r\n    // Validaciones\r\n    if (\r\n      gradosH === undefined ||\r\n      minutosH === undefined ||\r\n      segundosH === undefined ||\r\n      gradosV === undefined ||\r\n      minutosV === undefined ||\r\n      segundosV === undefined ||\r\n      distanciaObservada === \"\" ||\r\n      isNaN(distanciaObservada)\r\n    ) {\r\n      alert(\"Por favor, completa todos los campos con valores válidos.\");\r\n      return;\r\n    }\r\n\r\n    // Conversión de ángulo horizontal a decimal\r\n    const anguloObservadoDecimal = convertirGMSToDecimal(\r\n      Number(gradosH),\r\n      Number(minutosH),\r\n      Number(segundosH)\r\n    );\r\n    let nuevoAzimutCalculado;\r\n\r\n    if (contadorObservaciones === 0) {\r\n      nuevoAzimutCalculado = calcularAzimutObservacion();\r\n    } else {\r\n      const contraAzimut = calcularContraAzimut(ultimoAzimut);\r\n      nuevoAzimutCalculado = calcularAzimutSegundaObservacion(\r\n        contraAzimut,\r\n        anguloObservadoDecimal\r\n      );\r\n    }\r\n\r\n    const azimutSexagesimal = convertirDecimalAGMS(nuevoAzimutCalculado);\r\n\r\n    // Proyecciones Norte y Este\r\n    const { norte, este } = calcularProyecciones(\r\n      parseFloat(nuevoAzimutCalculado),\r\n      parseFloat(distanciaObservada)\r\n    );\r\n\r\n    // Cálculo de nuevas coordenadas\r\n    let nuevoNorte, nuevoEste;\r\n    if (contadorObservaciones === 0) {\r\n      ({ nuevoNorte, nuevoEste } = calcularCoordenadas(\r\n        norteInicial,\r\n        esteInicial,\r\n        norte,\r\n        este\r\n      ));\r\n    } else {\r\n      const { nuevoNorte: norteAnterior, nuevoEste: esteAnterior } =\r\n        observaciones[observaciones.length - 1];\r\n      ({ nuevoNorte, nuevoEste } = calcularCoordenadas(\r\n        norteAnterior,\r\n        esteAnterior,\r\n        norte,\r\n        este\r\n      ));\r\n    }\r\n\r\n    // Cálculo de la distancia vertical\r\n    const distanciaVertical = calcularDistanciaVerticalZenital(\r\n      gradosV,\r\n      minutosV,\r\n      segundosV,\r\n      distanciaObservada\r\n    );\r\n\r\n    // Cálculo de la altura\r\n    const alturaCalculada = calcularAlturaObservacion(\r\n      contadorObservaciones === 0\r\n        ? alturaInicial\r\n        : observaciones[observaciones.length - 1].alturaCalculada,\r\n      distanciaVertical,\r\n      alturaInstrumental,\r\n      alturaPrisma\r\n    );\r\n\r\n    // Crear el objeto de la nueva observación\r\n    const nuevaObservacion = {\r\n      id: idObservacion,\r\n      gradosH,\r\n      minutosH,\r\n      segundosH,\r\n      gradosV,\r\n      minutosV,\r\n      segundosV,\r\n      azimut: azimutSexagesimal,\r\n      anguloHorizontal: `${gradosH}° ${minutosH}' ${segundosH}\"`,\r\n      anguloVertical: `${gradosV}° ${minutosV}' ${segundosV}\"`,\r\n      distancia: distanciaObservada,\r\n      distanciaVertical, // Añadir la distancia vertical calculada aquí\r\n      alturaInstrumental,\r\n      alturaPrisma,\r\n      proyeccionNorte: norte,\r\n      proyeccionEste: este,\r\n      nuevoNorte,\r\n      nuevoEste,\r\n      alturaCalculada, // Guardar la altura calculada\r\n      alturaCalculada1: (\r\n        parseFloat(alturaInstrumental) +\r\n        parseFloat(distanciaVertical) -\r\n        parseFloat(alturaPrisma)\r\n      ).toFixed(4),\r\n    };\r\n\r\n    // Actualizar observaciones y recalcular totales\r\n    setObservaciones((prevObservaciones) => {\r\n      const nuevasObservaciones = [...prevObservaciones, nuevaObservacion];\r\n\r\n      // Llamamos a recalcularTotales después de agregar la nueva observación\r\n      recalcularTotales(nuevasObservaciones);\r\n      // Aquí calculamos el cierre de alturas con la observación recién agregada\r\n      calcularCierreAlturas(nuevasObservaciones);\r\n\r\n      return nuevasObservaciones;\r\n    });\r\n\r\n    // Actualización de totales directamente\r\n    setTotalDistancia(\r\n      (prevTotal) => prevTotal + parseFloat(distanciaObservada)\r\n    );\r\n    setTotalProyeccionNorte((prevTotal) => prevTotal + parseFloat(norte));\r\n    setTotalProyeccionEste((prevTotal) => prevTotal + parseFloat(este));\r\n\r\n    // Actualización de precisión\r\n    const nuevaPrecision = calcularPrecision(\r\n      totalDistancia + parseFloat(distanciaObservada),\r\n      totalProyeccionNorte + parseFloat(norte),\r\n      totalProyeccionEste + parseFloat(este)\r\n    );\r\n    setPrecisionPoligonal(nuevaPrecision);\r\n\r\n    setUltimoAzimut(parseFloat(nuevoAzimutCalculado));\r\n    setContadorObservaciones(contadorObservaciones + 1);\r\n\r\n    // Limpiar los campos de los inputs\r\n    setIdObservacion(\"\");\r\n    setGradosH(\"\");\r\n    setMinutosH(\"\");\r\n    setSegundosH(\"\");\r\n    setGradosV(\"\");\r\n    setMinutosV(\"\");\r\n    setSegundosV(\"\");\r\n    setDistanciaObservada(\"\");\r\n    setAlturaInstrumental(\"\");\r\n    setAlturaPrisma(\"\");\r\n  };\r\n\r\n  // Función para calcular la precisión de la poligonal\r\n  const calcularPrecision = (\r\n    distanciaTotal,\r\n    proyeccionNorteTotal,\r\n    proyeccionEsteTotal\r\n  ) => {\r\n    const sumatoriaProyecciones = Math.sqrt(\r\n      Math.pow(proyeccionNorteTotal, 2) + Math.pow(proyeccionEsteTotal, 2)\r\n    );\r\n    const precision = distanciaTotal / sumatoriaProyecciones;\r\n    return precision.toFixed(4); // Redondeamos a 4 decimales\r\n  };\r\n\r\n  const calcularContraAzimut = (azimut) => {\r\n    let contraAzimut;\r\n\r\n    if (azimut < 180) {\r\n      contraAzimut = azimut + 180;\r\n    } else {\r\n      contraAzimut = azimut - 180;\r\n    }\r\n\r\n    // Aseguramos que el contra-azimut esté en el rango de 0 a 360 grados\r\n    if (contraAzimut >= 360) {\r\n      contraAzimut -= 360;\r\n    }\r\n\r\n    return contraAzimut.toFixed(4); // Retornamos el contra-azimut redondeado a 4 decimales\r\n  };\r\n\r\n  const calcularAzimutSegundaObservacion = (\r\n    contraAzimut,\r\n    anguloObservadoDecimal\r\n  ) => {\r\n    let nuevoAzimut =\r\n      parseFloat(contraAzimut) + parseFloat(anguloObservadoDecimal);\r\n\r\n    // Si el nuevo azimut es mayor o igual a 360, restamos 360\r\n    if (nuevoAzimut >= 360) {\r\n      nuevoAzimut -= 360;\r\n    }\r\n\r\n    return nuevoAzimut.toFixed(4); // Retornamos el nuevo azimut redondeado a 4 decimales\r\n  };\r\n\r\n  const borrarUltimaObservacion = () => {\r\n    if (observaciones.length > 0) {\r\n      const ultimaObservacion = observaciones[observaciones.length - 1];\r\n\r\n      // Restar la distancia y proyecciones de la última observación\r\n      setTotalDistancia((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.distancia))\r\n      );\r\n      setTotalProyeccionNorte((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.proyeccionNorte))\r\n      );\r\n      setTotalProyeccionEste((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.proyeccionEste))\r\n      );\r\n\r\n      // Crear una nueva lista sin la última observación\r\n      const nuevasObservaciones = observaciones.slice(0, -1);\r\n      setObservaciones(nuevasObservaciones);\r\n\r\n      // Recalcular la precisión de la poligonal\r\n      const nuevaPrecision = calcularPrecision(\r\n        Math.max(0, totalDistancia - parseFloat(ultimaObservacion.distancia)),\r\n        Math.max(\r\n          0,\r\n          totalProyeccionNorte - parseFloat(ultimaObservacion.proyeccionNorte)\r\n        ),\r\n        Math.max(\r\n          0,\r\n          totalProyeccionEste - parseFloat(ultimaObservacion.proyeccionEste)\r\n        )\r\n      );\r\n      setPrecisionPoligonal(nuevaPrecision);\r\n\r\n      // Actualizar el contador de observaciones\r\n      setContadorObservaciones(contadorObservaciones - 1);\r\n\r\n      // Si todavía hay observaciones, actualiza el último azimut\r\n      if (nuevasObservaciones.length > 0) {\r\n        const ultimoAzimutAnterior =\r\n          nuevasObservaciones[nuevasObservaciones.length - 1].azimut;\r\n        const ultimoAzimutDecimal = convertirGMSToDecimal(\r\n          ...ultimoAzimutAnterior.split(/[°'\"]/).map((num) => parseFloat(num))\r\n        );\r\n        setUltimoAzimut(ultimoAzimutDecimal);\r\n      } else {\r\n        setUltimoAzimut(null);\r\n      }\r\n\r\n      // --- Recalcular el cierre angular ---\r\n      // Actualizamos el resumen angular de la poligonal después de eliminar la observación\r\n      calcularCierreAngular(nuevasObservaciones, sentidoPoligonal);\r\n    }\r\n  };\r\n\r\n  const compensarAngular = () => {\r\n    const N = observaciones.length;\r\n\r\n    // Evitar divisiones por cero si no hay observaciones\r\n    if (N === 0) return [];\r\n\r\n    // Si es brazo externo, omitimos el primer ángulo para la compensación\r\n    const observacionesACompensar = brazoExterno\r\n      ? observaciones.slice(1)\r\n      : observaciones;\r\n    const cantidadObservaciones = observacionesACompensar.length;\r\n\r\n    // Ajuste angular basado en la cantidad de ángulos a compensar (si brazo externo, N-1)\r\n    const ajusteAngular =\r\n      convertirAGradosDecimales(\r\n        errorAngular.grados,\r\n        errorAngular.minutos,\r\n        errorAngular.segundos\r\n      ) / cantidadObservaciones; // Ajuste en grados decimales basado en la cantidad de observaciones a compensar\r\n\r\n    // Crear un nuevo array de observaciones compensadas\r\n    const nuevasObservaciones = observaciones.map((obs, index) => {\r\n      // Si es la primera observación y el brazo es externo, devolverla sin cambios (mantener el ángulo tal cual)\r\n      if (index === 0 && brazoExterno) {\r\n        return {\r\n          ...obs,\r\n          anguloHorizontalCompensado: obs.anguloHorizontal, // Mantener el ángulo original\r\n        };\r\n      }\r\n\r\n      // Convertir el ángulo horizontal actual a decimal\r\n      const [grados, minutos, segundos] = obs.anguloHorizontal\r\n        .split(/[°'\"]/)\r\n        .map(parseFloat);\r\n\r\n      const anguloDec = convertirAGradosDecimales(grados, minutos, segundos);\r\n\r\n      // Aplicar el ajuste en grados decimales\r\n      const anguloCompensadoDec = anguloDec - ajusteAngular;\r\n\r\n      // Convertir de nuevo a GMS\r\n      const anguloCompensadoGMS = convertirDecimalAGMS(anguloCompensadoDec);\r\n\r\n      // Retornar la observación con el ángulo compensado\r\n      return {\r\n        ...obs,\r\n        anguloHorizontalCompensado: anguloCompensadoGMS, // Guardamos el ángulo compensado en GMS\r\n      };\r\n    });\r\n\r\n    return nuevasObservaciones; // Devolver las observaciones ajustadas\r\n  };\r\n  const ajustarAlturasVerticales = (observacionesCompensadas) => {\r\n    let alturaAcumulada;\r\n\r\n    // Usar la altura real de la primera observación como base si el brazo es externo\r\n    if (brazoExterno) {\r\n      alturaAcumulada = parseFloat(observacionesCompensadas[0].alturaCalculada);\r\n      console.log(\r\n        `\\n*** Brazo Externo: Usando altura de la primera observación como base: ${alturaAcumulada} ***`\r\n      );\r\n    } else {\r\n      // Si es brazo interno, partimos de la altura real calculada en la primera observación\r\n      alturaAcumulada = parseFloat(observacionesCompensadas[0].alturaCalculada);\r\n      console.log(\r\n        `\\n*** Brazo Interno: Usando altura inicial de la primera observación: ${alturaAcumulada} ***`\r\n      );\r\n    }\r\n\r\n    // Validar que la altura base sea válida\r\n    if (isNaN(alturaAcumulada)) {\r\n      console.error(\"Error: Altura inicial no válida.\");\r\n      alturaAcumulada = 0; // Manejo de error básico\r\n    }\r\n\r\n    // Ajustar las alturas progresivamente\r\n    const nuevasObservaciones = observacionesCompensadas.map((obs, index) => {\r\n      console.log(\r\n        `\\nCalculando altura compensada para la observación ${obs.id}`\r\n      );\r\n\r\n      if (index === 0 && brazoExterno) {\r\n        // La primera observación no se ajusta si el brazo es externo\r\n        obs.alturaCompensada = obs.alturaCalculada;\r\n        console.log(\r\n          `Brazo Externo - Primera observación sin ajuste: ${obs.alturaCompensada}`\r\n        );\r\n      } else {\r\n        // Validar la distancia vertical compensada\r\n        const distanciaVerticalCompensada = parseFloat(\r\n          obs.distanciaVerticalCompensada\r\n        );\r\n        if (isNaN(distanciaVerticalCompensada)) {\r\n          console.error(\r\n            `Error: La distancia vertical compensada no es válida para la observación ${obs.id}`\r\n          );\r\n          obs.alturaCompensada = \"NaN\"; // Manejo de error\r\n        } else {\r\n          // Calcular la nueva altura acumulada\r\n          alturaAcumulada += distanciaVerticalCompensada;\r\n\r\n          obs.alturaCompensada = alturaAcumulada.toFixed(4);\r\n          console.log(\r\n            `Altura acumulada y compensada para la observación ${obs.id}: ${obs.alturaCompensada}`\r\n          );\r\n        }\r\n      }\r\n\r\n      return obs;\r\n    });\r\n\r\n    return nuevasObservaciones;\r\n  };\r\n\r\n  const compensarProyeccionesYAlturas = (\r\n    nuevasObservaciones,\r\n    alturaInicial\r\n  ) => {\r\n    const errorNorte = totalProyeccionNorte; // Error en la proyección Norte\r\n    const errorEste = totalProyeccionEste; // Error en la proyección Este\r\n    const errorAlturas = cierreAlturas; // Error de cierre en alturas\r\n\r\n    // Filtrar la primera observación si el brazo es externo\r\n    const observacionesACompensar = brazoExterno\r\n      ? nuevasObservaciones.slice(1)\r\n      : nuevasObservaciones;\r\n\r\n    // Calcular el total de distancia solo de las observaciones que se van a compensar\r\n    const totalDistancia = observacionesACompensar.reduce(\r\n      (total, obs) => total + parseFloat(obs.distancia),\r\n      0\r\n    );\r\n\r\n    // Compensar las distancias verticales antes de ajustar las alturas\r\n    const observacionesConDistanciaCompensada = nuevasObservaciones.map(\r\n      (obs, index) => {\r\n        if (index === 0) {\r\n          return obs; // No compensar la primera observación si es brazo externo\r\n        }\r\n\r\n        // Calcular el ajuste de altura basado en la distancia\r\n        const ajusteAltura =\r\n          (Math.abs(errorAlturas) * obs.distancia) / totalDistancia;\r\n\r\n        // Validar la distancia vertical original\r\n        const distanciaVertical = parseFloat(obs.alturaCalculada1);\r\n        console.log(\r\n          `Distancia Vertical Original para observación ${obs.id}: ${distanciaVertical}`\r\n        );\r\n\r\n        if (isNaN(distanciaVertical)) {\r\n          console.error(\"Error: distanciaVertical no es un número válido\", obs);\r\n          obs.distanciaVerticalCompensada = \"NaN\";\r\n        } else {\r\n          // Ajustar según el signo del errorAlturas\r\n          const distanciaVerticalCompensada =\r\n            errorAlturas < 0\r\n              ? distanciaVertical + ajusteAltura // Sumar si errorAlturas es negativo\r\n              : distanciaVertical - ajusteAltura; // Restar si errorAlturas es positivo\r\n\r\n          console.log(\r\n            `Distancia Vertical Compensada para observación ${obs.id}: ${distanciaVerticalCompensada}`\r\n          );\r\n          obs.distanciaVerticalCompensada =\r\n            distanciaVerticalCompensada.toFixed(4); // Guardar la distancia vertical compensada\r\n        }\r\n\r\n        return obs;\r\n      }\r\n    );\r\n\r\n    // *** Ajustar las alturas verticales con la distancia compensada ***\r\n    const observacionesConAlturasAjustadas = ajustarAlturasVerticales(\r\n      observacionesConDistanciaCompensada,\r\n      alturaInicial\r\n    );\r\n\r\n    // Compensar proyecciones Norte y Este, además de ajustar las alturas calculadas\r\n    const observacionesFinales = observacionesConAlturasAjustadas.map(\r\n      (obs, index) => {\r\n        if (index === 0 && brazoExterno) {\r\n          // Si es la primera observación y el brazo es externo, no se ajusta pero se mantiene en la tabla\r\n          return {\r\n            ...obs,\r\n            proyeccionNorteCompensada: obs.proyeccionNorte,\r\n            proyeccionEsteCompensada: obs.proyeccionEste,\r\n            alturaCompensada: obs.alturaCompensada, // Mantener la altura calculada\r\n          };\r\n        }\r\n\r\n        // Aplicar ajustes a las proyecciones para el resto de las observaciones\r\n        const ajusteNorte = (errorNorte * obs.distancia) / totalDistancia;\r\n        const ajusteEste = (errorEste * obs.distancia) / totalDistancia;\r\n\r\n        const proyeccionNorteCompensada =\r\n          parseFloat(obs.proyeccionNorte) - ajusteNorte;\r\n        const proyeccionEsteCompensada =\r\n          parseFloat(obs.proyeccionEste) - ajusteEste;\r\n\r\n        return {\r\n          ...obs,\r\n          proyeccionNorteCompensada: proyeccionNorteCompensada.toFixed(4),\r\n          proyeccionEsteCompensada: proyeccionEsteCompensada.toFixed(4),\r\n          alturaCompensada: obs.alturaCompensada, // Mantener la altura compensada calculada\r\n        };\r\n      }\r\n    );\r\n\r\n    return observacionesFinales; // Retornar las observaciones compensadas con proyecciones y alturas ajustadas\r\n  };\r\n\r\n  const compensarPoligonal = () => {\r\n    const nuevasObservaciones = compensarAngular(); // Primero ajusta los ángulos\r\n\r\n    // Llama a la función de compensar proyecciones y alturas, incluyendo la altura inicial\r\n    const observacionesFinales = compensarProyeccionesYAlturas(\r\n      nuevasObservaciones,\r\n      alturaInicial // Asegúrate de que alturaInicial esté definida en tu estado o variable\r\n    );\r\n\r\n    setObservacionesCompensadas(observacionesFinales); // Actualizar el estado con las observaciones compensadas\r\n  };\r\n\r\n  // Función para recalcular las coordenadas con las proyecciones ajustadas\r\n  const recalcularCoordenadasAjustadas = (\r\n    norteAnterior,\r\n    esteAnterior,\r\n    proyeccionNorteAjustada,\r\n    proyeccionEsteAjustada\r\n  ) => {\r\n    const nuevoNorteAjustado =\r\n      parseFloat(norteAnterior) + parseFloat(proyeccionNorteAjustada);\r\n    const nuevoEsteAjustado =\r\n      parseFloat(esteAnterior) + parseFloat(proyeccionEsteAjustada);\r\n\r\n    return {\r\n      nuevoNorteAjustado: nuevoNorteAjustado.toFixed(4),\r\n      nuevoEsteAjustado: nuevoEsteAjustado.toFixed(4),\r\n    };\r\n  };\r\n\r\n  return (\r\n    <form\r\n      onSubmit={(e) => e.preventDefault()}\r\n      className=\"formulario-observacion\"\r\n    >\r\n      {!coordenadasCalculadas ? (\r\n        <>\r\n          {\" \"}\r\n          <div>\r\n            <label>Sentido de la Poligonal: </label>\r\n            <select\r\n              value={sentidoPoligonal}\r\n              onChange={(e) => setSentidoPoligonal(e.target.value)}\r\n            >\r\n              <option value=\"internos\">Ángulos Internos</option>\r\n              <option value=\"externos\">Ángulos Externos</option>\r\n            </select>\r\n          </div>\r\n          <div>\r\n            <label>Tipo de Brazo de la Poligonal: </label>\r\n            <select\r\n              value={brazoExterno ? \"externo\" : \"interno\"} // Determinar si el brazo es externo o interno\r\n              onChange={(e) => setBrazoExterno(e.target.value === \"externo\")}\r\n            >\r\n              <option value=\"interno\">Brazo Interno</option>{\" \"}\r\n              {/* Opción para poligonal interna */}\r\n              <option value=\"externo\">Brazo Externo</option>{\" \"}\r\n              {/* Opción para poligonal con brazo externo */}\r\n            </select>\r\n          </div>\r\n          <h3>Coordenadas del Punto Inicial (D1)</h3>\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Norte (Y)\"\r\n            value={norteInicial}\r\n            onChange={(e) => setNorteInicial(e.target.value)}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Este (X)\"\r\n            value={esteInicial}\r\n            onChange={(e) => setEsteInicial(e.target.value)}\r\n            required\r\n            clas\r\n            sName=\"coordenadas-input\"\r\n          />\r\n          {/* Nuevo input para la altura inicial */}\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Altura (m)\"\r\n            value={alturaInicial}\r\n            onChange={(e) => setAlturaInicial(e.target.value)} // Actualizar el estado de la altura inicial\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <h3>Coordenadas del Punto Visado (D2)</h3>\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Norte (Y)\"\r\n            value={norteVisado}\r\n            onChange={(e) => setNorteVisado(e.target.value)}\r\n            required\r\n          />\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Este (X)\"\r\n            value={esteVisado}\r\n            onChange={(e) => setEsteVisado(e.target.value)}\r\n            required\r\n          />\r\n          <button type=\"button\" onClick={calcularAzimutYAlmacenarValores}>\r\n            Calcular Azimut y Distancia\r\n          </button>\r\n        </>\r\n      ) : (\r\n        <>\r\n          <h3 style={{ margin: \"5px 0\" }}>\r\n            Azimut Inicial: {convertirDecimalAGMS(azimutInicial)}\r\n          </h3>\r\n          <h3 style={{ margin: \"5px 0\" }}>\r\n            Distancia Inicial: {distanciaInicial} metros\r\n          </h3>\r\n          <h3 className=\"header\">Ingresar Observación</h3>\r\n\r\n          <div className=\"row-container\">\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">ID Obs</h4>\r\n              <input\r\n                type=\"text\"\r\n                placeholder=\"ID\"\r\n                value={idObservacion}\r\n                onChange={(e) => setIdObservacion(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Ángulo Horizontal</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Grados\"\r\n                value={gradosH}\r\n                onChange={(e) => setGradosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Minutos\"\r\n                value={minutosH}\r\n                onChange={(e) => setMinutosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Segundos\"\r\n                value={segundosH}\r\n                onChange={(e) => setSegundosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Ángulo Vertical</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Grados\"\r\n                value={gradosV}\r\n                onChange={(e) => setGradosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Minutos\"\r\n                value={minutosV}\r\n                onChange={(e) => setMinutosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Segundos\"\r\n                value={segundosV}\r\n                onChange={(e) => setSegundosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Distancia (Metros)</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Distancia (m)\"\r\n                value={distanciaObservada}\r\n                onChange={(e) => setDistanciaObservada(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Altura Instrumental</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Altura Instrumental (m)\"\r\n                value={alturaInstrumental}\r\n                onChange={(e) => setAlturaInstrumental(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Altura Prisma</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Altura Prisma (m)\"\r\n                value={alturaPrisma}\r\n                onChange={(e) => setAlturaPrisma(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n          </div>\r\n\r\n          <button type=\"button\" onClick={agregarNuevaObservacion}>\r\n            Agregar Observación\r\n          </button>\r\n\r\n          {/* Mostrar el nuevo azimut calculado si está disponible */}\r\n          {nuevoAzimut && (\r\n            <h3>Nuevo Azimut: {convertirDecimalAGMS(nuevoAzimut)}</h3>\r\n          )}\r\n\r\n          {/* Tabla de observaciones */}\r\n          {observaciones.length > 0 && (\r\n            <>\r\n              {/* Primera tabla */}\r\n              <table border=\"1\" cellPadding=\"10\" cellSpacing=\"1\">\r\n                <thead>\r\n                  <tr>\r\n                    <th className=\"id\">ID</th>\r\n                    <th className=\"angulo\">Ángulo H</th>\r\n                    <th className=\"angulo\">Ángulo V</th>\r\n                    <th className=\"distancia\">Distancia</th>\r\n                    <th className=\"angulo\">Azimut</th>\r\n                    <th className=\"altura\">Alt Ins</th>\r\n                    <th className=\"altura\">Alt Pri</th>\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {observaciones.map((obs, index) => {\r\n                    return (\r\n                      <tr key={index}>\r\n                        <td>{obs.id}</td>\r\n                        <td>{obs.anguloHorizontal}</td>\r\n                        <td>{obs.anguloVertical}</td>\r\n                        <td>{obs.distancia} m</td>\r\n                        <td>{obs.azimut}</td>\r\n                        <td>{obs.alturaInstrumental} m</td>\r\n                        <td>{obs.alturaPrisma} m</td>\r\n                      </tr>\r\n                    );\r\n                  })}\r\n                </tbody>\r\n              </table>\r\n              <br /> {/* Espacio entre las dos tablas */}\r\n              {/* Segunda tabla */}\r\n              <table border=\"1\" cellPadding=\"10\" cellSpacing=\"1\">\r\n                <thead>\r\n                  <tr>\r\n                    <th className=\"proyeccion\">Proy Norte</th>\r\n                    <th className=\"proyeccion\">Proy Este</th>\r\n                    <th className=\"coordenada\">Norte</th>\r\n                    <th className=\"coordenada\">Este</th>\r\n                    <th className=\"altura\">Altura</th> {/* Nueva columna */}\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {observaciones.map((obs, index) => {\r\n                    // Calcular la distancia vertical zenital\r\n                    const distanciaVertical = calcularDistanciaVerticalZenital(\r\n                      obs.gradosV,\r\n                      obs.minutosV,\r\n                      obs.segundosV,\r\n                      obs.distancia\r\n                    );\r\n\r\n                    // Calcular la altura ajustada sobre el piso\r\n                    const alturaCalculada = calcularAlturaObservacion(\r\n                      index === 0\r\n                        ? alturaInicial\r\n                        : observaciones[index - 1].alturaCalculada,\r\n                      distanciaVertical,\r\n                      obs.alturaInstrumental,\r\n                      obs.alturaPrisma\r\n                    );\r\n\r\n                    // Guardar la altura calculada en el objeto de observación\r\n                    observaciones[index].alturaCalculada = alturaCalculada;\r\n\r\n                    return (\r\n                      <tr key={index}>\r\n                        <td>{obs.proyeccionNorte} m</td>\r\n                        <td>{obs.proyeccionEste} m</td>\r\n                        <td>{obs.nuevoNorte}</td>\r\n                        <td>{obs.nuevoEste}</td>\r\n                        <td>{alturaCalculada}</td>{\" \"}\r\n                        {/* Mostrar la altura calculada */}\r\n                      </tr>\r\n                    );\r\n                  })}\r\n                </tbody>\r\n              </table>\r\n              {/* Botón para borrar la última observación */}\r\n              <button type=\"button\" onClick={borrarUltimaObservacion}>\r\n                Borrar Última Observación\r\n              </button>\r\n              <>\r\n                {/* Resumen Angular de la Poligonal */}\r\n                <div className=\"resumen-angular\">\r\n                  <h3>Resumen Angular de la Poligonal</h3>\r\n                  <p>\r\n                    <strong>Suma Teórica:</strong>{\" \"}\r\n                    {`${sumaTeorica.grados}° ${sumaTeorica.minutos}' ${sumaTeorica.segundos}\"`}\r\n                  </p>\r\n                  <p>\r\n                    <strong>Suma Real:</strong>{\" \"}\r\n                    {`${sumaReal.grados}° ${sumaReal.minutos}' ${sumaReal.segundos}\"`}\r\n                  </p>\r\n                  <p>\r\n                    <strong>Error Angular:</strong>{\" \"}\r\n                    {`${errorAngular.grados}° ${errorAngular.minutos}' ${errorAngular.segundos}\"`}\r\n                  </p>\r\n                </div>\r\n\r\n                {/* Totales */}\r\n                <div className=\"totales\">\r\n                  <h3>Totales</h3>\r\n                  <p>\r\n                    <strong>Total Distancia:</strong>{\" \"}\r\n                    {totalDistancia.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Total Proyección Norte:</strong>{\" \"}\r\n                    {totalProyeccionNorte.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Total Proyección Este:</strong>{\" \"}\r\n                    {totalProyeccionEste.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Cierre Alturas:</strong> {cierreAlturas} m\r\n                  </p>\r\n                </div>\r\n\r\n                {/* Precisión de la Poligonal */}\r\n                <div className=\"precision-poligonal\">\r\n                  <h3>Precisión de la Poligonal</h3>\r\n                  <p>\r\n                    <strong>Precisión:</strong> {precisionPoligonal}\r\n                  </p>\r\n                </div>\r\n              </>\r\n            </>\r\n          )}\r\n          {/* Botón para compensar la poligonal */}\r\n          <button type=\"button\" onClick={compensarPoligonal}>\r\n            Compensar Poligonal\r\n          </button>\r\n\r\n          {/* Tabla de observaciones compensadas */}\r\n          {observacionesCompensadas.length > 0 && (\r\n            <>\r\n              <h3>Observaciones Compensadas</h3>\r\n              <table border=\"1\">\r\n                <thead>\r\n                  <tr>\r\n                    <th>ID</th>\r\n                    <th>Ángulo Horizontal Compensado</th>\r\n                    <th>Proyección Norte Compensada</th>\r\n                    <th>Proyección Este Compensada</th>\r\n                    <th>Norte Ajustado</th>\r\n                    <th>Este Ajustado</th>\r\n                    <th>Altura Compensada</th>{\" \"}\r\n                    {/* Asegúrate de tener esta columna */}\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {observacionesCompensadas.map((obs, index) => {\r\n                    // Recalcular las coordenadas ajustadas con las proyecciones compensadas\r\n                    const { nuevoNorteAjustado, nuevoEsteAjustado } =\r\n                      recalcularCoordenadasAjustadas(\r\n                        index === 0\r\n                          ? norteInicial // Para la primera observación usamos la coordenada inicial\r\n                          : observacionesCompensadas[index - 1]\r\n                              .nuevoNorteAjustado, // Para las demás usamos la coordenada ajustada anterior\r\n                        index === 0\r\n                          ? esteInicial\r\n                          : observacionesCompensadas[index - 1]\r\n                              .nuevoEsteAjustado, // Coordenada Este ajustada anterior\r\n                        obs.proyeccionNorteCompensada,\r\n                        obs.proyeccionEsteCompensada\r\n                      );\r\n\r\n                    // Actualizamos las coordenadas ajustadas en el objeto de observación compensada\r\n                    observacionesCompensadas[index].nuevoNorteAjustado =\r\n                      nuevoNorteAjustado;\r\n                    observacionesCompensadas[index].nuevoEsteAjustado =\r\n                      nuevoEsteAjustado;\r\n\r\n                    return (\r\n                      <tr key={index}>\r\n                        <td>{obs.id}</td>\r\n                        <td>{obs.anguloHorizontalCompensado}</td>\r\n                        <td>{obs.proyeccionNorteCompensada} m</td>\r\n                        <td>{obs.proyeccionEsteCompensada} m</td>\r\n                        <td>{nuevoNorteAjustado}</td>\r\n                        <td>{nuevoEsteAjustado}</td>\r\n                        <td>\r\n                          {isNaN(parseFloat(obs.alturaCompensada))\r\n                            ? \"-\"\r\n                            : parseFloat(obs.alturaCompensada).toFixed(3)}\r\n                        </td>\r\n                      </tr>\r\n                    );\r\n                  })}\r\n                </tbody>\r\n              </table>\r\n              {/* Añadir el gráfico aquí */}\r\n\r\n              <GraficoPoligonalSVG\r\n                observacionesCompensadas={observacionesCompensadas}\r\n              />\r\n            </>\r\n          )}\r\n        </>\r\n      )}\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default FormularioObservacion;\r\n","import React, { useState } from \"react\";\nimport FormularioObservacion from \"./components/FormularioObservacion\";\n\nimport \"./App.css\";\n\nfunction App() {\n  const [observaciones, setObservaciones] = useState([]);\n\n  const agregarObservacion = (observacion) => {\n    setObservaciones([...observaciones, observacion]);\n  };\n\n  return (\n    <div className=\"App\">\n      <h1>Cálculo de Poligonales</h1>\n      <FormularioObservacion agregarObservacion={agregarObservacion} />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}