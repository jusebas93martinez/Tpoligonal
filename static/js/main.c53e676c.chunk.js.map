{"version":3,"sources":["components/GraficoPoligonalSVG.js","components/FormularioObservacion.js","App.js","reportWebVitals.js","index.js"],"names":["GraficoPoligonal","_ref","observacionesCompensadas","colorLinea","setColorLinea","useState","grosorLinea","setGrosorLinea","colorPunto","setColorPunto","tamañoFlecha","setTamañoFlecha","colorFlecha","setColorFlecha","mostrarFlecha","setMostrarFlecha","mostrarMenu","setMostrarMenu","minX","Math","min","map","p","parseFloat","nuevoEsteAjustado","maxX","max","minY","nuevoNorteAjustado","maxY","rangoX","rangoY","escala","offsetX","offsetY","escalarX","valor","escalarY","React","createElement","style","position","border","width","height","padding","onClick","top","right","zIndex","left","backgroundColor","borderRadius","boxShadow","fontSize","display","marginBottom","type","value","onChange","e","target","marginTop","Number","checked","UncontrolledReactSVGPanZoom","background","tool","detectAutoPan","toolbarProps","transform","color","cursor","id","markerWidth","markerHeight","refX","refY","orient","markerUnits","d","fill","Array","from","length","ceil","anchoSVG","_","i","key","x1","y1","x2","y2","stroke","strokeWidth","altoSVG","index","cx","cy","r","data-tooltip-id","data-tooltip-content","x","y","markerEnd","FormularioObservacion","agregarObservacion","norteInicial","setNorteInicial","esteInicial","setEsteInicial","norteVisado","setNorteVisado","esteVisado","setEsteVisado","azimutInicial","setAzimutInicial","distanciaInicial","setDistanciaInicial","coordenadasCalculadas","setCoordenadasCalculadas","gradosH","setGradosH","minutosH","setMinutosH","segundosH","setSegundosH","gradosV","setGradosV","minutosV","setMinutosV","segundosV","setSegundosV","distanciaObservada","setDistanciaObservada","alturaInicial","setAlturaInicial","nuevoAzimut","setNuevoAzimut","sumaTeorica","setSumaTeorica","sumaReal","setSumaReal","errorAngular","setErrorAngular","sentidoPoligonal","setSentidoPoligonal","setObservacionesCompensadas","brazoExterno","setBrazoExterno","cierreAlturas","setCierreAlturas","descripcionInicial","setDescripcionInicial","descripcionVisado","setDescripcionVisado","coordenadas","setCoordenadas","calcularCierreAlturas","observacionesActualizadas","sumatoriaDistanciasVerticales","slice","reduce","acumulado","obs","distanciaVertical","alturaInstrumental","alturaPrisma","console","log","toFixed","calcularCierreAngular","observaciones","N","grados","minutos","segundos","contadorObservaciones","sumatoriaInicializada","forEach","angulo","sumarAngulos","restarAngulos","a1","a2","floor","convertirAGradosDecimales","mayor","menor","convertirGMSToDecimal","convertirDecimalAGMS","gradosDecimales","minutosDecimales","round","setObservaciones","setAlturaInstrumental","setAlturaPrisma","precisionPoligonal","setPrecisionPoligonal","idObservacion","setIdObservacion","calcularDistanciaVerticalZenital","anguloDecimal","anguloRad","convertirGradosARadianes","cos","calcularAlturaObservacion","PI","calcularCoordenadas","norteAnterior","esteAnterior","proyeccionNorte","proyeccionEste","nuevoNorte","nuevoEste","setContadorObservaciones","totalDistancia","setTotalDistancia","totalProyeccionNorte","setTotalProyeccionNorte","totalProyeccionEste","setTotalProyeccionEste","ultimoAzimut","setUltimoAzimut","calcularPrecision","distanciaTotal","proyeccionNorteTotal","proyeccionEsteTotal","sqrt","pow","calcularContraAzimut","azimut","contraAzimut","calcularAzimutSegundaObservacion","anguloObservadoDecimal","compensarProyeccionesYAlturas","nuevasObservaciones","errorNorte","errorEste","errorAlturas","total","distancia","alturaAcumulada","alturaCalculada","isNaN","error","alturaCompensada","distanciaVerticalCompensada","ajustarAlturasVerticales","ajusteAltura","abs","alturaCalculada1","proyeccionNorteCompensada","proyeccionEsteCompensada","ajusteNorte","ajusteEste","onSubmit","preventDefault","className","Fragment","margin","placeholder","agregarNuevaObservacion","undefined","alert","nuevoAzimutCalculado","calcularAzimutObservacion","anguloHorizontalDecimal","calcularNuevoAzimut","azimutSexagesimal","norte","este","calcularProyecciones","azimutRad","sin","nuevaObservacion","anguloHorizontal","anguloVertical","prevObservaciones","observacionesFiltradas","nuevasDistancias","acc","nuevasProyeccionesNorte","nuevasProyeccionesEste","nuevaPrecision","recalcularTotales","prevTotal","cellPadding","cellSpacing","borrarUltimaObservacion","ultimaObservacion","ultimoAzimutAnterior","ultimoAzimutDecimal","split","num","compensarPoligonal","compensarAngular","cantidadObservaciones","ajusteAngular","anguloHorizontalCompensado","anguloDec","anguloCompensadoGMS","observacionesFinales","recalcularCoordenadasAjustadas","proyeccionNorteAjustada","proyeccionEsteAjustada","test","required","calcularAzimutYAlmacenarValores","calcularAzimutYDistanciaDesdeCoordenadas","deltaX","deltaY","azimutDeg","atan2","coord","altura","App","observacion","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.c53e676c.chunk.js","sourcesContent":["import React, { useState } from \"react\";\r\nimport ReactTooltip from \"react-tooltip\";\r\nimport { UncontrolledReactSVGPanZoom } from \"react-svg-pan-zoom\"; // Pan y zoom para el SVG\r\n\r\nconst GraficoPoligonal = ({ observacionesCompensadas = [] }) => {\r\n  const [colorLinea, setColorLinea] = useState(\"blue\");\r\n  const [grosorLinea, setGrosorLinea] = useState(2);\r\n  const [colorPunto, setColorPunto] = useState(\"red\");\r\n  const [tamañoFlecha, setTamañoFlecha] = useState(10);\r\n  const [colorFlecha, setColorFlecha] = useState(\"blue\");\r\n  const [mostrarFlecha, setMostrarFlecha] = useState(true);\r\n  const [mostrarMenu, setMostrarMenu] = useState(false); // Estado para controlar la visibilidad del menú\r\n\r\n  const anchoSVG = 320;\r\n  const altoSVG = 550;\r\n  const gridSpacing = 100; // Espaciado de la cuadrícula\r\n\r\n  // Calcula los valores mínimos y máximos de las coordenadas ajustadas\r\n  const minX = Math.min(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoEsteAjustado))\r\n  );\r\n  const maxX = Math.max(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoEsteAjustado))\r\n  );\r\n  const minY = Math.min(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoNorteAjustado))\r\n  );\r\n  const maxY = Math.max(\r\n    ...observacionesCompensadas.map((p) => parseFloat(p.nuevoNorteAjustado))\r\n  );\r\n\r\n  // Agrega un margen del 10% alrededor de los extremos\r\n  const margen = 0.01; // 10% de margen\r\n\r\n  const rangoX = (maxX - minX) * (1 + margen);\r\n  const rangoY = (maxY - minY) * (1 + margen);\r\n\r\n  // Calcula la escala para ajustar la poligonal al tamaño del SVG\r\n  const escala = Math.min(anchoSVG / rangoX, altoSVG / rangoY);\r\n\r\n  // Centra la poligonal en el SVG\r\n  const offsetX = (anchoSVG - (maxX - minX) * escala) / 2;\r\n  const offsetY = (altoSVG - (maxY - minY) * escala) / 2;\r\n\r\n  // Función para escalar las coordenadas al tamaño del SVG\r\n  const escalarX = (valor) => (valor - minX) * escala + offsetX;\r\n  const escalarY = (valor) => altoSVG - (valor - minY) * escala - offsetY; // Invertir el eje Y para el SVG\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        position: \"relative\",\r\n        border: \"2px solid black\",\r\n        width: `${anchoSVG}px`,\r\n        height: `${altoSVG}px`,\r\n        padding: \"10px\",\r\n      }}\r\n    >\r\n      {/* Botón para mostrar/ocultar el menú */}\r\n      <button\r\n        onClick={() => setMostrarMenu(!mostrarMenu)} // Alternar visibilidad del menú\r\n        style={{\r\n          position: \"absolute\",\r\n          top: \"5px\",\r\n          right: \"5px\",\r\n          zIndex: 11, // Asegura que esté encima del SVG\r\n        }}\r\n      >\r\n        {mostrarMenu ? \"Ocultar Configuración\" : \"Mostrar Configuración\"}\r\n      </button>\r\n\r\n      {/* Menú de configuración flotante */}\r\n      {mostrarMenu && (\r\n        <div\r\n          style={{\r\n            position: \"absolute\",\r\n            top: \"40px\",\r\n            left: \"5px\",\r\n            backgroundColor: \"white\",\r\n            padding: \"10px\",\r\n            borderRadius: \"8px\",\r\n            boxShadow: \"0px 4px 10px rgba(0, 0, 0, 0.1)\",\r\n            zIndex: 10,\r\n            fontSize: \"10px\",\r\n          }}\r\n        >\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Color de la línea:\r\n            <input\r\n              type=\"color\"\r\n              value={colorLinea}\r\n              onChange={(e) => setColorLinea(e.target.value)}\r\n              style={{ width: \"40%\", marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Grosor de la línea:\r\n            <input\r\n              type=\"number\"\r\n              min=\"1\"\r\n              max=\"50\"\r\n              value={grosorLinea}\r\n              onChange={(e) => setGrosorLinea(Number(e.target.value))}\r\n              style={{ width: \"30%\", marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Color del punto:\r\n            <input\r\n              type=\"color\"\r\n              value={colorPunto}\r\n              onChange={(e) => setColorPunto(e.target.value)}\r\n              style={{ width: \"40%\", marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Tamaño de la flecha:\r\n            <input\r\n              type=\"number\"\r\n              min=\"5\"\r\n              max=\"40\"\r\n              value={tamañoFlecha}\r\n              onChange={(e) => setTamañoFlecha(Number(e.target.value))}\r\n              style={{ width: \"30%\", marginTop: \"2px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Color de la flecha:\r\n            <input\r\n              type=\"color\"\r\n              value={colorFlecha}\r\n              onChange={(e) => setColorFlecha(e.target.value)}\r\n              style={{ width: \"40%\", marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n          <label style={{ display: \"block\", marginBottom: \"5px\" }}>\r\n            Mostrar flecha:\r\n            <input\r\n              type=\"checkbox\"\r\n              checked={mostrarFlecha}\r\n              onChange={(e) => setMostrarFlecha(e.target.checked)}\r\n              style={{ marginTop: \"3px\" }}\r\n            />\r\n          </label>\r\n        </div>\r\n      )}\r\n\r\n      {/* Renderización del SVG con pan y zoom */}\r\n      <UncontrolledReactSVGPanZoom\r\n        width={anchoSVG}\r\n        height={altoSVG}\r\n        background=\"transparent\"\r\n        tool=\"auto\"\r\n        detectAutoPan={false}\r\n        toolbarProps={{ position: \"none\" }}\r\n      >\r\n        <div\r\n          style={{\r\n            position: \"relative\",\r\n            width: `${anchoSVG}px`,\r\n            height: `${altoSVG}px`,\r\n          }}\r\n        >\r\n          {/* Botón para mostrar/ocultar configuración */}\r\n          <button\r\n            onClick={() => setMostrarMenu(!mostrarMenu)}\r\n            style={{\r\n              position: \"absolute\",\r\n              top: \"-35px\", // Ajusta la posición del botón hacia arriba\r\n              left: \"50%\",\r\n              transform: \"translateX(-50%)\", // Centra horizontalmente el botón\r\n              backgroundColor: \"#007bff\",\r\n              color: \"white\",\r\n              border: \"none\",\r\n              padding: \"10px 20px\",\r\n              borderRadius: \"8px\",\r\n              cursor: \"pointer\",\r\n              zIndex: 10, // Asegura que esté por encima del gráfico\r\n            }}\r\n          >\r\n            {mostrarMenu ? \"Ocultar Configuración\" : \"Mostrar Configuración\"}\r\n          </button>\r\n\r\n          {/* SVG que contiene el gráfico */}\r\n          <svg\r\n            width={anchoSVG}\r\n            height={altoSVG}\r\n            style={{ border: \"2px solid black\", zIndex: 1 }}\r\n          >\r\n            {/* Aquí va la cuadrícula, los puntos y las líneas */}\r\n            <defs>\r\n              <marker\r\n                id=\"arrow\"\r\n                markerWidth={tamañoFlecha}\r\n                markerHeight={tamañoFlecha}\r\n                refX=\"10\"\r\n                refY=\"3\"\r\n                orient=\"auto\"\r\n                markerUnits=\"strokeWidth\"\r\n              >\r\n                <path d=\"M0,0 L0,6 L9,3 z\" fill={colorFlecha} />\r\n              </marker>\r\n            </defs>\r\n\r\n            {/* Renderización de la cuadrícula */}\r\n            {Array.from({ length: Math.ceil(anchoSVG / gridSpacing) }).map(\r\n              (_, i) => (\r\n                <line\r\n                  key={`v-grid-${i}`}\r\n                  x1={i * gridSpacing}\r\n                  y1={0}\r\n                  x2={i * gridSpacing}\r\n                  y2={altoSVG}\r\n                  stroke=\"#d3d3d3\"\r\n                  strokeWidth=\"1\"\r\n                />\r\n              )\r\n            )}\r\n            {Array.from({ length: Math.ceil(altoSVG / gridSpacing) }).map(\r\n              (_, i) => (\r\n                <line\r\n                  key={`h-grid-${i}`}\r\n                  x1={0}\r\n                  y1={i * gridSpacing}\r\n                  x2={anchoSVG}\r\n                  y2={i * gridSpacing}\r\n                  stroke=\"#d3d3d3\"\r\n                  strokeWidth=\"1\"\r\n                />\r\n              )\r\n            )}\r\n\r\n            {/* Renderización de los puntos y las líneas */}\r\n            {observacionesCompensadas.map((p, index) => {\r\n              const cx = escalarX(parseFloat(p.nuevoEsteAjustado));\r\n              const cy = escalarY(parseFloat(p.nuevoNorteAjustado));\r\n              return (\r\n                <g key={index}>\r\n                  <circle\r\n                    cx={cx}\r\n                    cy={cy}\r\n                    r=\"6\"\r\n                    fill={colorPunto}\r\n                    data-tooltip-id={`tooltip-${index}`}\r\n                    data-tooltip-content={`ID: ${p.id}, Norte: ${p.nuevoNorteAjustado}, Este: ${p.nuevoEsteAjustado}`}\r\n                    style={{ cursor: \"pointer\" }}\r\n                  />\r\n                  <text x={cx + 5} y={cy - 5} fontSize=\"12\" fill=\"black\">\r\n                    {p.id}\r\n                  </text>\r\n                </g>\r\n              );\r\n            })}\r\n\r\n            {observacionesCompensadas.map((p, index) => {\r\n              if (index < observacionesCompensadas.length - 1) {\r\n                const x1 = escalarX(parseFloat(p.nuevoEsteAjustado));\r\n                const y1 = escalarY(parseFloat(p.nuevoNorteAjustado));\r\n                const x2 = escalarX(\r\n                  parseFloat(\r\n                    observacionesCompensadas[index + 1].nuevoEsteAjustado\r\n                  )\r\n                );\r\n                const y2 = escalarY(\r\n                  parseFloat(\r\n                    observacionesCompensadas[index + 1].nuevoNorteAjustado\r\n                  )\r\n                );\r\n                return (\r\n                  <line\r\n                    key={index}\r\n                    x1={x1}\r\n                    y1={y1}\r\n                    x2={x2}\r\n                    y2={y2}\r\n                    stroke={colorLinea}\r\n                    strokeWidth={grosorLinea}\r\n                    markerEnd={mostrarFlecha ? \"url(#arrow)\" : null}\r\n                  />\r\n                );\r\n              }\r\n              return null;\r\n            })}\r\n\r\n            {observacionesCompensadas.length > 2 && (\r\n              <line\r\n                x1={escalarX(\r\n                  parseFloat(\r\n                    observacionesCompensadas[\r\n                      observacionesCompensadas.length - 1\r\n                    ].nuevoEsteAjustado\r\n                  )\r\n                )}\r\n                y1={escalarY(\r\n                  parseFloat(\r\n                    observacionesCompensadas[\r\n                      observacionesCompensadas.length - 1\r\n                    ].nuevoNorteAjustado\r\n                  )\r\n                )}\r\n                x2={escalarX(\r\n                  parseFloat(observacionesCompensadas[0].nuevoEsteAjustado)\r\n                )}\r\n                y2={escalarY(\r\n                  parseFloat(observacionesCompensadas[0].nuevoNorteAjustado)\r\n                )}\r\n                stroke={colorLinea}\r\n                strokeWidth={grosorLinea}\r\n                markerEnd={mostrarFlecha ? \"url(#arrow)\" : null}\r\n              />\r\n            )}\r\n          </svg>\r\n        </div>\r\n      </UncontrolledReactSVGPanZoom>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GraficoPoligonal;\r\n","import React, { useState } from \"react\";\r\nimport GraficoPoligonal from \"./GraficoPoligonalSVG\";\r\n\r\nconst FormularioObservacion = ({ agregarObservacion }) => {\r\n  // Estados para coordenadas y observaciones\r\n  const [norteInicial, setNorteInicial] = useState(\"\");\r\n  const [esteInicial, setEsteInicial] = useState(\"\");\r\n  const [norteVisado, setNorteVisado] = useState(\"\");\r\n  const [esteVisado, setEsteVisado] = useState(\"\");\r\n\r\n  const [azimutInicial, setAzimutInicial] = useState(null); // Estado para el azimut inicial\r\n  const [distanciaInicial, setDistanciaInicial] = useState(null); // Estado para la distancia inicial\r\n  const [coordenadasCalculadas, setCoordenadasCalculadas] = useState(false); // Para controlar si ya calculaste las coordenadas\r\n\r\n  // Estados para los ángulos y la distancia observada\r\n  const [gradosH, setGradosH] = useState(\"\");\r\n  const [minutosH, setMinutosH] = useState(\"\");\r\n  const [segundosH, setSegundosH] = useState(\"\");\r\n\r\n  const [gradosV, setGradosV] = useState(\"\");\r\n  const [minutosV, setMinutosV] = useState(\"\");\r\n  const [segundosV, setSegundosV] = useState(\"\");\r\n\r\n  const [distanciaObservada, setDistanciaObservada] = useState(\"\");\r\n  const [alturaInicial, setAlturaInicial] = useState(\"\"); // Nueva variable para la altura inicial\r\n\r\n  const [nuevoAzimut, setNuevoAzimut] = useState(null); // Estado para el nuevo azimut calculado\r\n\r\n  const [sumaTeorica, setSumaTeorica] = useState(0);\r\n  const [sumaReal, setSumaReal] = useState(0);\r\n  const [errorAngular, setErrorAngular] = useState(0);\r\n\r\n  const [sentidoPoligonal, setSentidoPoligonal] = useState(\"internos\"); // 'internos' o 'externos'\r\n  const [observacionesCompensadas, setObservacionesCompensadas] = useState([]); // Para las observaciones ajustadas\r\n  // Suponiendo que tienes estos estados definidos en algún lugar del componente\r\n  const [brazoExterno, setBrazoExterno] = useState(false); // Por defecto, el brazo es interno\r\n  const [cierreAlturas, setCierreAlturas] = useState(0); // Estado para almacenar el cierre de alturas\r\n  const [descripcionInicial, setDescripcionInicial] = useState(\"\");\r\n  const [descripcionVisado, setDescripcionVisado] = useState(\"\");\r\n  const [coordenadas, setCoordenadas] = useState([]);\r\n  const calcularCierreAlturas = (observacionesActualizadas) => {\r\n    if (observacionesActualizadas.length === 0) {\r\n      setCierreAlturas(0); // Si no hay observaciones, el cierre de alturas es 0\r\n      return 0;\r\n    }\r\n\r\n    // Filtrar las observaciones según el tipo de brazo\r\n    const observacionesAConsiderar = brazoExterno\r\n      ? observacionesActualizadas.slice(1) // Si es brazo externo, omitimos la primera observación\r\n      : observacionesActualizadas; // Si es brazo interno, usamos todas las observaciones\r\n\r\n    // Calcular la sumatoria de las distancias verticales reales (valor absoluto)\r\n    const sumatoriaDistanciasVerticales = observacionesAConsiderar.reduce(\r\n      (acumulado, obs) =>\r\n        acumulado +\r\n        parseFloat(obs.distanciaVertical) + // Tomamos el valor absoluto de la distancia vertical\r\n        parseFloat(obs.alturaInstrumental) -\r\n        parseFloat(obs.alturaPrisma),\r\n      0\r\n    );\r\n\r\n    console.log(\r\n      `\\nSumatoria de Distancias Verticales Calculadas: ${sumatoriaDistanciasVerticales.toFixed(\r\n        4\r\n      )}`\r\n    );\r\n\r\n    // Guardar y retornar el cierre de alturas manteniendo el signo\r\n    const cierreAlturas = sumatoriaDistanciasVerticales.toFixed(4);\r\n    setCierreAlturas(cierreAlturas);\r\n\r\n    console.log(`Cierre de alturas calculado: ${cierreAlturas}`);\r\n\r\n    return parseFloat(cierreAlturas); // Retornamos el valor numérico con su signo\r\n  };\r\n\r\n  const calcularCierreAngular = (observaciones, sentidoPoligonal) => {\r\n    const N = observaciones.length;\r\n    if (N === 0) return;\r\n\r\n    // Inicializamos la sumatoria de los ángulos con 0° 0' 0\"\r\n    let sumaReal = { grados: 0, minutos: 0, segundos: 0 };\r\n\r\n    // Contador para rastrear el número de observaciones\r\n    let contadorObservaciones = 0;\r\n\r\n    // Bandera para saber si ya hemos inicializado la suma con la segunda observación\r\n    let sumatoriaInicializada = false;\r\n\r\n    // Iteramos sobre las observaciones\r\n    observaciones.forEach((obs) => {\r\n      contadorObservaciones++; // Incrementamos el contador por cada observación\r\n\r\n      // Si es la primera observación y el brazo es externo, la ignoramos\r\n      if (contadorObservaciones === 0 && brazoExterno) {\r\n        return; // Salta la primera observación\r\n      }\r\n\r\n      // Convertir los valores del ángulo de la observación actual\r\n      const angulo = {\r\n        grados: Number(obs.gradosH),\r\n        minutos: Number(obs.minutosH),\r\n        segundos: Number(obs.segundosH),\r\n      };\r\n\r\n      // Si es la segunda observación y la primera fue omitida, inicializamos la sumatoria\r\n      if (\r\n        contadorObservaciones === 0 &&\r\n        brazoExterno &&\r\n        !sumatoriaInicializada\r\n      ) {\r\n        sumaReal = angulo; // Iniciamos la sumatoria con el ángulo de la segunda observación\r\n        sumatoriaInicializada = true; // Marcamos que ya hemos inicializado la sumatoria\r\n      } else {\r\n        // Para todas las demás observaciones, sumamos los ángulos normalmente\r\n        sumaReal = sumarAngulos(sumaReal, angulo);\r\n      }\r\n    });\r\n\r\n    // Calculamos la suma teórica dependiendo del tipo de poligonal\r\n    let sumaTeorica;\r\n    if (sentidoPoligonal === \"internos\") {\r\n      sumaTeorica = { grados: (N - 2) * 180, minutos: 0, segundos: 0 };\r\n    } else {\r\n      sumaTeorica = { grados: (N + 2) * 180, minutos: 0, segundos: 0 };\r\n    }\r\n\r\n    // Calculamos el error angular\r\n    const errorAngular = restarAngulos(sumaTeorica, sumaReal);\r\n\r\n    // Actualizamos los estados con los valores finales\r\n    setSumaTeorica(sumaTeorica);\r\n    setSumaReal(sumaReal);\r\n    setErrorAngular(errorAngular);\r\n  };\r\n\r\n  const sumarAngulos = (a1, a2) => {\r\n    let segundos = Number(a1.segundos) + Number(a2.segundos);\r\n    let minutos = Number(a1.minutos) + Number(a2.minutos);\r\n    let grados = Number(a1.grados) + Number(a2.grados);\r\n\r\n    // Ajustar segundos si exceden 60\r\n    if (segundos >= 60) {\r\n      minutos += Math.floor(segundos / 60);\r\n      segundos = segundos % 60;\r\n    }\r\n\r\n    // Ajustar minutos si exceden 60\r\n    if (minutos >= 60) {\r\n      grados += Math.floor(minutos / 60);\r\n      minutos = minutos % 60;\r\n    }\r\n\r\n    return { grados, minutos, segundos };\r\n  };\r\n\r\n  const convertirAGradosDecimales = (grados, minutos, segundos) => {\r\n    return grados + minutos / 60 + segundos / 3600;\r\n  };\r\n\r\n  const restarAngulos = (a1, a2) => {\r\n    // Convertir los ángulos a grados decimales para compararlos\r\n    const angulo1Decimal = convertirAGradosDecimales(\r\n      a1.grados,\r\n      a1.minutos,\r\n      a1.segundos\r\n    );\r\n    const angulo2Decimal = convertirAGradosDecimales(\r\n      a2.grados,\r\n      a2.minutos,\r\n      a2.segundos\r\n    );\r\n\r\n    // Determinar cuál es el mayor y el menor\r\n    let mayor, menor;\r\n    if (angulo1Decimal >= angulo2Decimal) {\r\n      mayor = a1;\r\n      menor = a2;\r\n    } else {\r\n      mayor = a2;\r\n      menor = a1;\r\n    }\r\n\r\n    // Restar ángulos (siempre mayor - menor)\r\n    let segundos = mayor.segundos - menor.segundos;\r\n    let minutos = mayor.minutos - menor.minutos;\r\n    let grados = mayor.grados - menor.grados;\r\n\r\n    // Si los segundos son negativos, pedir prestado 1 minuto\r\n    if (segundos < 0) {\r\n      segundos += 60;\r\n      minutos -= 1;\r\n    }\r\n\r\n    // Si los minutos son negativos, pedir prestado 1 grado\r\n    if (minutos < 0) {\r\n      minutos += 60;\r\n      grados -= 1;\r\n    }\r\n\r\n    return { grados, minutos, segundos };\r\n  };\r\n\r\n  // Función para convertir GMS a grados decimales\r\n  const convertirGMSToDecimal = (grados, minutos, segundos) => {\r\n    return (\r\n      parseFloat(grados) +\r\n      parseFloat(minutos) / 60 +\r\n      parseFloat(segundos) / 3600\r\n    );\r\n  };\r\n  const convertirDecimalAGMS = (gradosDecimales) => {\r\n    const grados = Math.floor(gradosDecimales); // Parte entera para los grados\r\n    const minutosDecimales = (gradosDecimales - grados) * 60;\r\n    const minutos = Math.floor(minutosDecimales); // Parte entera para los minutos\r\n    const segundos = Math.round((minutosDecimales - minutos) * 60); // Redondear los segundos a enteros\r\n\r\n    return `${grados}° ${minutos}' ${segundos}\"`;\r\n  };\r\n\r\n  // Estado para almacenar todas las observaciones\r\n  const [observaciones, setObservaciones] = useState([]);\r\n\r\n  // Estados para las alturas\r\n  const [alturaInstrumental, setAlturaInstrumental] = useState(\"\");\r\n  const [alturaPrisma, setAlturaPrisma] = useState(\"\");\r\n\r\n  // Estado para almacenar la precisión de la poligonal\r\n  const [precisionPoligonal, setPrecisionPoligonal] = useState(0);\r\n\r\n  // Estado para el ID de la observación\r\n  const [idObservacion, setIdObservacion] = useState(\"\");\r\n\r\n  // Función para calcular el azimut inicial y la distancia a partir de coordenadas\r\n  const calcularAzimutYDistanciaDesdeCoordenadas = (\r\n    norteInicial,\r\n    esteInicial,\r\n    norteVisado,\r\n    esteVisado\r\n  ) => {\r\n    const deltaX = parseFloat(esteVisado) - parseFloat(esteInicial);\r\n    const deltaY = parseFloat(norteVisado) - parseFloat(norteInicial);\r\n\r\n    // Azimut inicial en grados\r\n    let azimutRad = Math.atan2(deltaX, deltaY);\r\n    let azimutDeg = azimutRad * (180 / Math.PI); // Convertimos de radianes a grados\r\n\r\n    // Ajustar el azimut para que esté en el rango de 0 a 360 grados\r\n    if (azimutDeg < 0) {\r\n      azimutDeg += 360;\r\n    } else if (azimutDeg >= 360) {\r\n      azimutDeg -= 360;\r\n    }\r\n\r\n    // Calcular la distancia entre D1 y D2\r\n    const distancia = Math.sqrt(deltaX ** 2 + deltaY ** 2);\r\n\r\n    // Retornar el azimut y la distancia\r\n    return {\r\n      azimut: azimutDeg.toFixed(4), // Redondear azimut a 4 decimales\r\n      distancia: distancia.toFixed(4), // Redondear distancia a 4 decimales\r\n    };\r\n  };\r\n\r\n  // Función que calcula y almacena azimut y distancia\r\n  const calcularAzimutYAlmacenarValores = () => {\r\n    const { azimut, distancia } = calcularAzimutYDistanciaDesdeCoordenadas(\r\n      norteInicial,\r\n      esteInicial,\r\n      norteVisado,\r\n      esteVisado\r\n    );\r\n\r\n    // Almacenar los valores calculados en el estado\r\n    setAzimutInicial(azimut);\r\n    setDistanciaInicial(distancia);\r\n\r\n    setCoordenadasCalculadas(true); // Cambiar el estado para ocultar los inputs de coordenadas si corresponde\r\n  };\r\n\r\n  // Función para calcular la distancia vertical zenital\r\n  const calcularDistanciaVerticalZenital = (\r\n    grados,\r\n    minutos,\r\n    segundos,\r\n    distanciaObservada\r\n  ) => {\r\n    // Convertimos los grados a decimales\r\n    const anguloDecimal = convertirGMSToDecimal(grados, minutos, segundos);\r\n\r\n    // Convertimos el ángulo a radianes\r\n    const anguloRad = convertirGradosARadianes(anguloDecimal);\r\n\r\n    // Calculamos la distancia vertical usando el coseno del ángulo\r\n    const distanciaVertical = distanciaObservada * Math.cos(anguloRad);\r\n\r\n    return distanciaVertical.toFixed(4); // Redondear a 4 decimales\r\n  };\r\n\r\n  const calcularAlturaObservacion = (\r\n    alturaInicial,\r\n    distanciaVertical,\r\n    alturaInstrumental,\r\n    alturaPrisma\r\n  ) => {\r\n    // Calcular la altura final sobre el piso\r\n    const alturaFinal =\r\n      parseFloat(alturaInicial) +\r\n      parseFloat(alturaInstrumental) -\r\n      parseFloat(alturaPrisma) +\r\n      parseFloat(distanciaVertical);\r\n    return alturaFinal.toFixed(4); // Redondear a 4 decimales\r\n  };\r\n\r\n  // Función para calcular el nuevo azimut basado en el azimut inicial y el ángulo observado\r\n  const calcularNuevoAzimut = (azimutInicial, anguloObservadoDecimal) => {\r\n    let nuevoAzimut = azimutInicial + anguloObservadoDecimal;\r\n\r\n    // Si el azimut es mayor o igual a 360, restamos 360 para ajustarlo\r\n    if (nuevoAzimut >= 360) {\r\n      nuevoAzimut -= 360;\r\n    }\r\n\r\n    return nuevoAzimut.toFixed(4); // Retornamos el nuevo azimut en grados decimales\r\n  };\r\n\r\n  // Función para calcular y almacenar el nuevo azimut basado en la observación\r\n  const calcularAzimutObservacion = () => {\r\n    // Convertir ángulo observado (horizontal) a grados decimales\r\n    const anguloHorizontalDecimal = convertirGMSToDecimal(\r\n      gradosH,\r\n      minutosH,\r\n      segundosH\r\n    );\r\n\r\n    // Calcular el nuevo azimut basado en el ángulo observado y el azimut inicial\r\n    const nuevoAzimutCalculado = calcularNuevoAzimut(\r\n      parseFloat(azimutInicial),\r\n      anguloHorizontalDecimal\r\n    );\r\n\r\n    // Guardar el nuevo azimut en el estado\r\n    setNuevoAzimut(nuevoAzimutCalculado);\r\n\r\n    return nuevoAzimutCalculado;\r\n  };\r\n\r\n  // Función para convertir grados a radianes\r\n  const convertirGradosARadianes = (grados) => {\r\n    return (grados * Math.PI) / 180;\r\n  };\r\n\r\n  // Función para calcular las proyecciones Norte y Este\r\n  const calcularProyecciones = (azimut, distancia) => {\r\n    const azimutRad = convertirGradosARadianes(azimut); // Convertir el azimut a radianes\r\n\r\n    // Proyección Norte (coseno del azimut por la distancia)\r\n    const proyeccionNorte = Math.cos(azimutRad) * distancia;\r\n\r\n    // Proyección Este (seno del azimut por la distancia)\r\n    const proyeccionEste = Math.sin(azimutRad) * distancia;\r\n\r\n    // Retornamos las proyecciones redondeadas a 4 decimales\r\n    return {\r\n      norte: proyeccionNorte.toFixed(4),\r\n      este: proyeccionEste.toFixed(4),\r\n    };\r\n  };\r\n\r\n  // Función para calcular las nuevas coordenadas\r\n  const calcularCoordenadas = (\r\n    norteAnterior,\r\n    esteAnterior,\r\n    proyeccionNorte,\r\n    proyeccionEste\r\n  ) => {\r\n    const nuevoNorte = parseFloat(norteAnterior) + parseFloat(proyeccionNorte);\r\n    const nuevoEste = parseFloat(esteAnterior) + parseFloat(proyeccionEste);\r\n\r\n    return {\r\n      nuevoNorte: nuevoNorte.toFixed(4), // Redondear a 4 decimales\r\n      nuevoEste: nuevoEste.toFixed(4), // Redondear a 4 decimales\r\n    };\r\n  };\r\n  const [contadorObservaciones, setContadorObservaciones] = useState(0); // Contador para saber cuántas observaciones se han hecho\r\n  // Estados para los totales\r\n  const [totalDistancia, setTotalDistancia] = useState(0);\r\n  const [totalProyeccionNorte, setTotalProyeccionNorte] = useState(0);\r\n  const [totalProyeccionEste, setTotalProyeccionEste] = useState(0);\r\n\r\n  // Estado para almacenar el último azimut calculado (usado para las siguientes observaciones)\r\n  const [ultimoAzimut, setUltimoAzimut] = useState(null);\r\n\r\n  const recalcularTotales = (nuevasObservaciones) => {\r\n    // Filtrar la primera observación si el brazo es externo\r\n    const observacionesFiltradas = brazoExterno\r\n      ? nuevasObservaciones.slice(1)\r\n      : nuevasObservaciones;\r\n\r\n    calcularCierreAngular(observacionesFiltradas, sentidoPoligonal);\r\n    calcularCierreAlturas(observacionesFiltradas, alturaInicial);\r\n\r\n    const nuevasDistancias = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.distancia),\r\n      0\r\n    );\r\n\r\n    const nuevasProyeccionesNorte = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.proyeccionNorte),\r\n      0\r\n    );\r\n    const nuevasProyeccionesEste = observacionesFiltradas.reduce(\r\n      (acc, obs) => acc + parseFloat(obs.proyeccionEste),\r\n      0\r\n    );\r\n\r\n    setTotalDistancia(nuevasDistancias);\r\n    setTotalProyeccionNorte(nuevasProyeccionesNorte);\r\n    setTotalProyeccionEste(nuevasProyeccionesEste);\r\n\r\n    const nuevaPrecision = calcularPrecision(\r\n      nuevasDistancias,\r\n      nuevasProyeccionesNorte,\r\n      nuevasProyeccionesEste\r\n    );\r\n    setPrecisionPoligonal(nuevaPrecision);\r\n  };\r\n\r\n  const agregarNuevaObservacion = () => {\r\n    // Validaciones\r\n    if (\r\n      gradosH === undefined ||\r\n      minutosH === undefined ||\r\n      segundosH === undefined ||\r\n      gradosV === undefined ||\r\n      minutosV === undefined ||\r\n      segundosV === undefined ||\r\n      distanciaObservada === \"\" ||\r\n      isNaN(distanciaObservada)\r\n    ) {\r\n      alert(\"Por favor, completa todos los campos con valores válidos.\");\r\n      return;\r\n    }\r\n\r\n    // Conversión de ángulo horizontal a decimal\r\n    const anguloObservadoDecimal = convertirGMSToDecimal(\r\n      Number(gradosH),\r\n      Number(minutosH),\r\n      Number(segundosH)\r\n    );\r\n    let nuevoAzimutCalculado;\r\n\r\n    if (contadorObservaciones === 0) {\r\n      nuevoAzimutCalculado = calcularAzimutObservacion();\r\n    } else {\r\n      const contraAzimut = calcularContraAzimut(ultimoAzimut);\r\n      nuevoAzimutCalculado = calcularAzimutSegundaObservacion(\r\n        contraAzimut,\r\n        anguloObservadoDecimal\r\n      );\r\n    }\r\n\r\n    const azimutSexagesimal = convertirDecimalAGMS(nuevoAzimutCalculado);\r\n\r\n    // Proyecciones Norte y Este\r\n    const { norte, este } = calcularProyecciones(\r\n      parseFloat(nuevoAzimutCalculado),\r\n      parseFloat(distanciaObservada)\r\n    );\r\n\r\n    // Cálculo de nuevas coordenadas\r\n    let nuevoNorte, nuevoEste;\r\n    if (contadorObservaciones === 0) {\r\n      ({ nuevoNorte, nuevoEste } = calcularCoordenadas(\r\n        norteInicial,\r\n        esteInicial,\r\n        norte,\r\n        este\r\n      ));\r\n    } else {\r\n      const { nuevoNorte: norteAnterior, nuevoEste: esteAnterior } =\r\n        observaciones[observaciones.length - 1];\r\n      ({ nuevoNorte, nuevoEste } = calcularCoordenadas(\r\n        norteAnterior,\r\n        esteAnterior,\r\n        norte,\r\n        este\r\n      ));\r\n    }\r\n\r\n    // Cálculo de la distancia vertical\r\n    const distanciaVertical = calcularDistanciaVerticalZenital(\r\n      gradosV,\r\n      minutosV,\r\n      segundosV,\r\n      distanciaObservada\r\n    );\r\n\r\n    // Cálculo de la altura\r\n    const alturaCalculada = calcularAlturaObservacion(\r\n      contadorObservaciones === 0\r\n        ? alturaInicial\r\n        : observaciones[observaciones.length - 1].alturaCalculada,\r\n      distanciaVertical,\r\n      alturaInstrumental,\r\n      alturaPrisma\r\n    );\r\n\r\n    // Crear el objeto de la nueva observación\r\n    const nuevaObservacion = {\r\n      id: idObservacion,\r\n      gradosH,\r\n      minutosH,\r\n      segundosH,\r\n      gradosV,\r\n      minutosV,\r\n      segundosV,\r\n      azimut: azimutSexagesimal,\r\n      anguloHorizontal: `${gradosH}° ${minutosH}' ${segundosH}\"`,\r\n      anguloVertical: `${gradosV}° ${minutosV}' ${segundosV}\"`,\r\n      distancia: distanciaObservada,\r\n      distanciaVertical, // Añadir la distancia vertical calculada aquí\r\n      alturaInstrumental,\r\n      alturaPrisma,\r\n      proyeccionNorte: norte,\r\n      proyeccionEste: este,\r\n      nuevoNorte,\r\n      nuevoEste,\r\n      alturaCalculada, // Guardar la altura calculada\r\n      alturaCalculada1: (\r\n        parseFloat(alturaInstrumental) +\r\n        parseFloat(distanciaVertical) -\r\n        parseFloat(alturaPrisma)\r\n      ).toFixed(4),\r\n    };\r\n\r\n    // Actualizar observaciones y recalcular totales\r\n    setObservaciones((prevObservaciones) => {\r\n      const nuevasObservaciones = [...prevObservaciones, nuevaObservacion];\r\n\r\n      // Llamamos a recalcularTotales después de agregar la nueva observación\r\n      recalcularTotales(nuevasObservaciones);\r\n      // Aquí calculamos el cierre de alturas con la observación recién agregada\r\n      calcularCierreAlturas(nuevasObservaciones);\r\n\r\n      return nuevasObservaciones;\r\n    });\r\n\r\n    // Actualización de totales directamente\r\n    setTotalDistancia(\r\n      (prevTotal) => prevTotal + parseFloat(distanciaObservada)\r\n    );\r\n    setTotalProyeccionNorte((prevTotal) => prevTotal + parseFloat(norte));\r\n    setTotalProyeccionEste((prevTotal) => prevTotal + parseFloat(este));\r\n\r\n    // Actualización de precisión\r\n    const nuevaPrecision = calcularPrecision(\r\n      totalDistancia + parseFloat(distanciaObservada),\r\n      totalProyeccionNorte + parseFloat(norte),\r\n      totalProyeccionEste + parseFloat(este)\r\n    );\r\n    setPrecisionPoligonal(nuevaPrecision);\r\n\r\n    setUltimoAzimut(parseFloat(nuevoAzimutCalculado));\r\n    setContadorObservaciones(contadorObservaciones + 1);\r\n\r\n    // Limpiar los campos de los inputs\r\n    setIdObservacion(\"\");\r\n    setGradosH(\"\");\r\n    setMinutosH(\"\");\r\n    setSegundosH(\"\");\r\n    setGradosV(\"\");\r\n    setMinutosV(\"\");\r\n    setSegundosV(\"\");\r\n    setDistanciaObservada(\"\");\r\n    setAlturaInstrumental(\"\");\r\n    setAlturaPrisma(\"\");\r\n  };\r\n\r\n  // Función para calcular la precisión de la poligonal\r\n  const calcularPrecision = (\r\n    distanciaTotal,\r\n    proyeccionNorteTotal,\r\n    proyeccionEsteTotal\r\n  ) => {\r\n    const sumatoriaProyecciones = Math.sqrt(\r\n      Math.pow(proyeccionNorteTotal, 2) + Math.pow(proyeccionEsteTotal, 2)\r\n    );\r\n    const precision = distanciaTotal / sumatoriaProyecciones;\r\n    return precision.toFixed(4); // Redondeamos a 4 decimales\r\n  };\r\n\r\n  const calcularContraAzimut = (azimut) => {\r\n    let contraAzimut;\r\n\r\n    if (azimut < 180) {\r\n      contraAzimut = azimut + 180;\r\n    } else {\r\n      contraAzimut = azimut - 180;\r\n    }\r\n\r\n    // Aseguramos que el contra-azimut esté en el rango de 0 a 360 grados\r\n    if (contraAzimut >= 360) {\r\n      contraAzimut -= 360;\r\n    }\r\n\r\n    return contraAzimut.toFixed(4); // Retornamos el contra-azimut redondeado a 4 decimales\r\n  };\r\n\r\n  const calcularAzimutSegundaObservacion = (\r\n    contraAzimut,\r\n    anguloObservadoDecimal\r\n  ) => {\r\n    let nuevoAzimut =\r\n      parseFloat(contraAzimut) + parseFloat(anguloObservadoDecimal);\r\n\r\n    // Si el nuevo azimut es mayor o igual a 360, restamos 360\r\n    if (nuevoAzimut >= 360) {\r\n      nuevoAzimut -= 360;\r\n    }\r\n\r\n    return nuevoAzimut.toFixed(4); // Retornamos el nuevo azimut redondeado a 4 decimales\r\n  };\r\n\r\n  const borrarUltimaObservacion = () => {\r\n    if (observaciones.length > 0) {\r\n      const ultimaObservacion = observaciones[observaciones.length - 1];\r\n\r\n      // Restar la distancia y proyecciones de la última observación\r\n      setTotalDistancia((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.distancia))\r\n      );\r\n      setTotalProyeccionNorte((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.proyeccionNorte))\r\n      );\r\n      setTotalProyeccionEste((prevTotal) =>\r\n        Math.max(0, prevTotal - parseFloat(ultimaObservacion.proyeccionEste))\r\n      );\r\n\r\n      // Crear una nueva lista sin la última observación\r\n      const nuevasObservaciones = observaciones.slice(0, -1);\r\n      setObservaciones(nuevasObservaciones);\r\n\r\n      // Recalcular la precisión de la poligonal\r\n      const nuevaPrecision = calcularPrecision(\r\n        Math.max(0, totalDistancia - parseFloat(ultimaObservacion.distancia)),\r\n        Math.max(\r\n          0,\r\n          totalProyeccionNorte - parseFloat(ultimaObservacion.proyeccionNorte)\r\n        ),\r\n        Math.max(\r\n          0,\r\n          totalProyeccionEste - parseFloat(ultimaObservacion.proyeccionEste)\r\n        )\r\n      );\r\n      setPrecisionPoligonal(nuevaPrecision);\r\n\r\n      // Actualizar el contador de observaciones\r\n      setContadorObservaciones(contadorObservaciones - 1);\r\n\r\n      // Si todavía hay observaciones, actualiza el último azimut\r\n      if (nuevasObservaciones.length > 0) {\r\n        const ultimoAzimutAnterior =\r\n          nuevasObservaciones[nuevasObservaciones.length - 1].azimut;\r\n        const ultimoAzimutDecimal = convertirGMSToDecimal(\r\n          ...ultimoAzimutAnterior.split(/[°'\"]/).map((num) => parseFloat(num))\r\n        );\r\n        setUltimoAzimut(ultimoAzimutDecimal);\r\n      } else {\r\n        setUltimoAzimut(null);\r\n      }\r\n\r\n      // --- Recalcular el cierre angular ---\r\n      // Actualizamos el resumen angular de la poligonal después de eliminar la observación\r\n      calcularCierreAngular(nuevasObservaciones, sentidoPoligonal);\r\n    }\r\n  };\r\n\r\n  const compensarAngular = () => {\r\n    const N = observaciones.length;\r\n\r\n    // Evitar divisiones por cero si no hay observaciones\r\n    if (N === 0) return [];\r\n\r\n    // Si es brazo externo, omitimos el primer ángulo para la compensación\r\n    const observacionesACompensar = brazoExterno\r\n      ? observaciones.slice(1)\r\n      : observaciones;\r\n    const cantidadObservaciones = observacionesACompensar.length;\r\n\r\n    // Ajuste angular basado en la cantidad de ángulos a compensar (si brazo externo, N-1)\r\n    const ajusteAngular =\r\n      convertirAGradosDecimales(\r\n        errorAngular.grados,\r\n        errorAngular.minutos,\r\n        errorAngular.segundos\r\n      ) / cantidadObservaciones; // Ajuste en grados decimales basado en la cantidad de observaciones a compensar\r\n\r\n    // Crear un nuevo array de observaciones compensadas\r\n    const nuevasObservaciones = observaciones.map((obs, index) => {\r\n      // Si es la primera observación y el brazo es externo, devolverla sin cambios (mantener el ángulo tal cual)\r\n      if (index === 0 && brazoExterno) {\r\n        return {\r\n          ...obs,\r\n          anguloHorizontalCompensado: obs.anguloHorizontal, // Mantener el ángulo original\r\n        };\r\n      }\r\n\r\n      // Convertir el ángulo horizontal actual a decimal\r\n      const [grados, minutos, segundos] = obs.anguloHorizontal\r\n        .split(/[°'\"]/)\r\n        .map(parseFloat);\r\n\r\n      const anguloDec = convertirAGradosDecimales(grados, minutos, segundos);\r\n\r\n      // Aplicar el ajuste en grados decimales\r\n      const anguloCompensadoDec = anguloDec - ajusteAngular;\r\n\r\n      // Convertir de nuevo a GMS\r\n      const anguloCompensadoGMS = convertirDecimalAGMS(anguloCompensadoDec);\r\n\r\n      // Retornar la observación con el ángulo compensado\r\n      return {\r\n        ...obs,\r\n        anguloHorizontalCompensado: anguloCompensadoGMS, // Guardamos el ángulo compensado en GMS\r\n      };\r\n    });\r\n\r\n    return nuevasObservaciones; // Devolver las observaciones ajustadas\r\n  };\r\n  const ajustarAlturasVerticales = (observacionesCompensadas) => {\r\n    let alturaAcumulada;\r\n\r\n    // Usar la altura real de la primera observación como base si el brazo es externo\r\n    if (brazoExterno) {\r\n      alturaAcumulada = parseFloat(observacionesCompensadas[0].alturaCalculada);\r\n      console.log(\r\n        `\\n*** Brazo Externo: Usando altura de la primera observación como base: ${alturaAcumulada} ***`\r\n      );\r\n    } else {\r\n      // Si es brazo interno, partimos de la altura real calculada en la primera observación\r\n      alturaAcumulada = parseFloat(observacionesCompensadas[0].alturaCalculada);\r\n      console.log(\r\n        `\\n*** Brazo Interno: Usando altura inicial de la primera observación: ${alturaAcumulada} ***`\r\n      );\r\n    }\r\n\r\n    // Validar que la altura base sea válida\r\n    if (isNaN(alturaAcumulada)) {\r\n      console.error(\"Error: Altura inicial no válida.\");\r\n      alturaAcumulada = 0; // Manejo de error básico\r\n    }\r\n\r\n    // Ajustar las alturas progresivamente\r\n    const nuevasObservaciones = observacionesCompensadas.map((obs, index) => {\r\n      console.log(\r\n        `\\nCalculando altura compensada para la observación ${obs.id}`\r\n      );\r\n\r\n      if (index === 0 && brazoExterno) {\r\n        // La primera observación no se ajusta si el brazo es externo\r\n        obs.alturaCompensada = obs.alturaCalculada;\r\n        console.log(\r\n          `Brazo Externo - Primera observación sin ajuste: ${obs.alturaCompensada}`\r\n        );\r\n      } else {\r\n        // Validar la distancia vertical compensada\r\n        const distanciaVerticalCompensada = parseFloat(\r\n          obs.distanciaVerticalCompensada\r\n        );\r\n        if (isNaN(distanciaVerticalCompensada)) {\r\n          console.error(\r\n            `Error: La distancia vertical compensada no es válida para la observación ${obs.id}`\r\n          );\r\n          obs.alturaCompensada = \"NaN\"; // Manejo de error\r\n        } else {\r\n          // Calcular la nueva altura acumulada\r\n          alturaAcumulada += distanciaVerticalCompensada;\r\n\r\n          obs.alturaCompensada = alturaAcumulada.toFixed(4);\r\n          console.log(\r\n            `Altura acumulada y compensada para la observación ${obs.id}: ${obs.alturaCompensada}`\r\n          );\r\n        }\r\n      }\r\n\r\n      return obs;\r\n    });\r\n\r\n    return nuevasObservaciones;\r\n  };\r\n\r\n  const compensarProyeccionesYAlturas = (\r\n    nuevasObservaciones,\r\n    alturaInicial\r\n  ) => {\r\n    const errorNorte = totalProyeccionNorte; // Error en la proyección Norte\r\n    const errorEste = totalProyeccionEste; // Error en la proyección Este\r\n    const errorAlturas = cierreAlturas; // Error de cierre en alturas\r\n\r\n    // Filtrar la primera observación si el brazo es externo\r\n    const observacionesACompensar = brazoExterno\r\n      ? nuevasObservaciones.slice(1)\r\n      : nuevasObservaciones;\r\n\r\n    // Calcular el total de distancia solo de las observaciones que se van a compensar\r\n    const totalDistancia = observacionesACompensar.reduce(\r\n      (total, obs) => total + parseFloat(obs.distancia),\r\n      0\r\n    );\r\n\r\n    // Compensar las distancias verticales antes de ajustar las alturas\r\n    const observacionesConDistanciaCompensada = nuevasObservaciones.map(\r\n      (obs, index) => {\r\n        if (index === 0) {\r\n          return obs; // No compensar la primera observación si es brazo externo\r\n        }\r\n\r\n        // Calcular el ajuste de altura basado en la distancia\r\n        const ajusteAltura =\r\n          (Math.abs(errorAlturas) * obs.distancia) / totalDistancia;\r\n\r\n        // Validar la distancia vertical original\r\n        const distanciaVertical = parseFloat(obs.alturaCalculada1);\r\n        console.log(\r\n          `Distancia Vertical Original para observación ${obs.id}: ${distanciaVertical}`\r\n        );\r\n\r\n        if (isNaN(distanciaVertical)) {\r\n          console.error(\"Error: distanciaVertical no es un número válido\", obs);\r\n          obs.distanciaVerticalCompensada = \"NaN\";\r\n        } else {\r\n          // Ajustar según el signo del errorAlturas\r\n          const distanciaVerticalCompensada =\r\n            errorAlturas < 0\r\n              ? distanciaVertical + ajusteAltura // Sumar si errorAlturas es negativo\r\n              : distanciaVertical - ajusteAltura; // Restar si errorAlturas es positivo\r\n\r\n          console.log(\r\n            `Distancia Vertical Compensada para observación ${obs.id}: ${distanciaVerticalCompensada}`\r\n          );\r\n          obs.distanciaVerticalCompensada =\r\n            distanciaVerticalCompensada.toFixed(4); // Guardar la distancia vertical compensada\r\n        }\r\n\r\n        return obs;\r\n      }\r\n    );\r\n\r\n    // *** Ajustar las alturas verticales con la distancia compensada ***\r\n    const observacionesConAlturasAjustadas = ajustarAlturasVerticales(\r\n      observacionesConDistanciaCompensada,\r\n      alturaInicial\r\n    );\r\n\r\n    // Compensar proyecciones Norte y Este, además de ajustar las alturas calculadas\r\n    const observacionesFinales = observacionesConAlturasAjustadas.map(\r\n      (obs, index) => {\r\n        if (index === 0 && brazoExterno) {\r\n          // Si es la primera observación y el brazo es externo, no se ajusta pero se mantiene en la tabla\r\n          return {\r\n            ...obs,\r\n            proyeccionNorteCompensada: obs.proyeccionNorte,\r\n            proyeccionEsteCompensada: obs.proyeccionEste,\r\n            alturaCompensada: obs.alturaCompensada, // Mantener la altura calculada\r\n          };\r\n        }\r\n\r\n        // Aplicar ajustes a las proyecciones para el resto de las observaciones\r\n        const ajusteNorte = (errorNorte * obs.distancia) / totalDistancia;\r\n        const ajusteEste = (errorEste * obs.distancia) / totalDistancia;\r\n\r\n        const proyeccionNorteCompensada =\r\n          parseFloat(obs.proyeccionNorte) - ajusteNorte;\r\n        const proyeccionEsteCompensada =\r\n          parseFloat(obs.proyeccionEste) - ajusteEste;\r\n\r\n        return {\r\n          ...obs,\r\n          proyeccionNorteCompensada: proyeccionNorteCompensada.toFixed(4),\r\n          proyeccionEsteCompensada: proyeccionEsteCompensada.toFixed(4),\r\n          alturaCompensada: obs.alturaCompensada, // Mantener la altura compensada calculada\r\n        };\r\n      }\r\n    );\r\n\r\n    return observacionesFinales; // Retornar las observaciones compensadas con proyecciones y alturas ajustadas\r\n  };\r\n\r\n  const compensarPoligonal = () => {\r\n    const nuevasObservaciones = compensarAngular(); // Primero ajusta los ángulos\r\n\r\n    // Llama a la función de compensar proyecciones y alturas, incluyendo la altura inicial\r\n    const observacionesFinales = compensarProyeccionesYAlturas(\r\n      nuevasObservaciones,\r\n      alturaInicial // Asegúrate de que alturaInicial esté definida en tu estado o variable\r\n    );\r\n\r\n    setObservacionesCompensadas(observacionesFinales); // Actualizar el estado con las observaciones compensadas\r\n  };\r\n\r\n  // Función para recalcular las coordenadas con las proyecciones ajustadas\r\n  const recalcularCoordenadasAjustadas = (\r\n    norteAnterior,\r\n    esteAnterior,\r\n    proyeccionNorteAjustada,\r\n    proyeccionEsteAjustada\r\n  ) => {\r\n    const nuevoNorteAjustado =\r\n      parseFloat(norteAnterior) + parseFloat(proyeccionNorteAjustada);\r\n    const nuevoEsteAjustado =\r\n      parseFloat(esteAnterior) + parseFloat(proyeccionEsteAjustada);\r\n\r\n    return {\r\n      nuevoNorteAjustado: nuevoNorteAjustado.toFixed(4),\r\n      nuevoEsteAjustado: nuevoEsteAjustado.toFixed(4),\r\n    };\r\n  };\r\n\r\n  return (\r\n    <form\r\n      onSubmit={(e) => e.preventDefault()}\r\n      className=\"formulario-observacion\"\r\n    >\r\n      {!coordenadasCalculadas ? (\r\n        <>\r\n          {\" \"}\r\n          <div>\r\n            <label>Sentido de la Poligonal: </label>\r\n            <select\r\n              value={sentidoPoligonal}\r\n              onChange={(e) => setSentidoPoligonal(e.target.value)}\r\n            >\r\n              <option value=\"internos\">Ángulos Internos</option>\r\n              <option value=\"externos\">Ángulos Externos</option>\r\n            </select>\r\n          </div>\r\n          <div>\r\n            <label>Tipo de Brazo de la Poligonal: </label>\r\n            <select\r\n              value={brazoExterno ? \"externo\" : \"interno\"} // Determinar si el brazo es externo o interno\r\n              onChange={(e) => setBrazoExterno(e.target.value === \"externo\")}\r\n            >\r\n              <option value=\"interno\">Brazo Interno</option>{\" \"}\r\n              {/* Opción para poligonal interna */}\r\n              <option value=\"externo\">Brazo Externo</option>{\" \"}\r\n              {/* Opción para poligonal con brazo externo */}\r\n            </select>\r\n          </div>\r\n          <h3>Descripción y Coordenadas del Punto Inicial</h3>\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Descripción del Punto Inicial\"\r\n            value={descripcionInicial}\r\n            onChange={(e) => setDescripcionInicial(e.target.value)}\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Norte (Y)\"\r\n            value={norteInicial}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setNorteInicial(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Este (X)\"\r\n            value={esteInicial}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setEsteInicial(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          {/* Nuevo input para la altura inicial */}\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Altura (m)\"\r\n            value={alturaInicial}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setAlturaInicial(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <h3>Descripción y Coordenadas del Punto Visado</h3>\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Descripción del Punto Visado\"\r\n            value={descripcionVisado}\r\n            onChange={(e) => setDescripcionVisado(e.target.value)}\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Norte (Y)\"\r\n            value={norteVisado}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setNorteVisado(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <input\r\n            type=\"number\"\r\n            placeholder=\"Este (X)\"\r\n            value={esteVisado}\r\n            onChange={(e) => {\r\n              const value = e.target.value;\r\n              if (/^[0-9]*[.,]?[0-9]*$/.test(value)) {\r\n                // Solo números y punto decimal\r\n                setEsteVisado(value);\r\n              }\r\n            }}\r\n            required\r\n            className=\"coordenadas-input\"\r\n          />\r\n          <button type=\"button\" onClick={calcularAzimutYAlmacenarValores}>\r\n            Calcular Azimut y Distancia\r\n          </button>\r\n          {coordenadas.length > 0 && (\r\n            <table border=\"1\" style={{ marginTop: \"20px\" }}>\r\n              <thead>\r\n                <tr>\r\n                  <th>ID</th>\r\n                  <th>Norte (Y)</th>\r\n                  <th>Este (X)</th>\r\n                  <th>Altura (m)</th>\r\n                </tr>\r\n              </thead>\r\n              <tbody>\r\n                {coordenadas.map((coord, index) => (\r\n                  <tr key={index}>\r\n                    <td>{coord.id}</td>\r\n                    <td>{coord.norte}</td>\r\n                    <td>{coord.este}</td>\r\n                    <td>{coord.altura || \"N/A\"}</td>\r\n                  </tr>\r\n                ))}\r\n              </tbody>\r\n            </table>\r\n          )}\r\n        </>\r\n      ) : (\r\n        <>\r\n          <h3 style={{ margin: \"5px 0\" }}>\r\n            Azimut Inicial: {convertirDecimalAGMS(azimutInicial)}\r\n          </h3>\r\n          <h3 style={{ margin: \"5px 0\" }}>\r\n            Distancia Inicial: {distanciaInicial} metros\r\n          </h3>\r\n          <h3 className=\"header\">Ingresar Observación</h3>\r\n          <div className=\"row-container\">\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">ID Obs</h4>\r\n              <input\r\n                type=\"text\"\r\n                placeholder=\"ID\"\r\n                value={idObservacion}\r\n                onChange={(e) => setIdObservacion(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Ángulo Horizontal</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Grados\"\r\n                value={gradosH}\r\n                onChange={(e) => setGradosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Minutos\"\r\n                value={minutosH}\r\n                onChange={(e) => setMinutosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Segundos\"\r\n                value={segundosH}\r\n                onChange={(e) => setSegundosH(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Ángulo Vertical</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Grados\"\r\n                value={gradosV}\r\n                onChange={(e) => setGradosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Minutos\"\r\n                value={minutosV}\r\n                onChange={(e) => setMinutosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Segundos\"\r\n                value={segundosV}\r\n                onChange={(e) => setSegundosV(Number(e.target.value))}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Distancia (Metros)</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Distancia (m)\"\r\n                value={distanciaObservada}\r\n                onChange={(e) => setDistanciaObservada(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Altura Instrumental</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Altura Instrumental (m)\"\r\n                value={alturaInstrumental}\r\n                onChange={(e) => setAlturaInstrumental(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n\r\n            <div className=\"input-group\">\r\n              <h4 className=\"header\">Altura Prisma</h4>\r\n              <input\r\n                type=\"number\"\r\n                placeholder=\"Altura Prisma (m)\"\r\n                value={alturaPrisma}\r\n                onChange={(e) => setAlturaPrisma(e.target.value)}\r\n                className=\"input-field\"\r\n              />\r\n            </div>\r\n          </div>\r\n          <button type=\"button\" onClick={agregarNuevaObservacion}>\r\n            Agregar Observación\r\n          </button>\r\n          {/* Mostrar el nuevo azimut calculado si está disponible */}\r\n          {nuevoAzimut && (\r\n            <h3>Nuevo Azimut: {convertirDecimalAGMS(nuevoAzimut)}</h3>\r\n          )}\r\n          {/* Tabla de observaciones */}\r\n          {observaciones.length > 0 && (\r\n            <>\r\n              {/* Primera tabla */}\r\n              <table border=\"1\" cellPadding=\"10\" cellSpacing=\"1\">\r\n                <thead>\r\n                  <tr>\r\n                    <th className=\"id\">ID</th>\r\n                    <th className=\"angulo\">Ángulo H</th>\r\n                    <th className=\"angulo\">Ángulo V</th>\r\n                    <th className=\"distancia\">Distancia</th>\r\n                    <th className=\"angulo\">Azimut</th>\r\n                    <th className=\"altura\">Alt Ins</th>\r\n                    <th className=\"altura\">Alt Pri</th>\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {observaciones.map((obs, index) => (\r\n                    <tr key={index}>\r\n                      <td>{obs.id}</td>\r\n                      <td>{obs.anguloHorizontal}</td>\r\n                      <td>{obs.anguloVertical}</td>\r\n                      <td>{obs.distancia}m</td>\r\n                      <td>{obs.azimut}</td>\r\n                      <td>{obs.alturaInstrumental}m</td>\r\n                      <td>{obs.alturaPrisma}m</td>\r\n                    </tr>\r\n                  ))}\r\n                </tbody>\r\n              </table>\r\n              <br /> {/* Espacio entre las dos tablas */}\r\n              {/* Segunda tabla */}\r\n              <table border=\"1\" cellPadding=\"10\" cellSpacing=\"1\">\r\n                <thead>\r\n                  <tr>\r\n                    <th className=\"id\">ID</th> {/* Agregar la columna ID */}\r\n                    <th className=\"proyeccion\">Proy Norte</th>\r\n                    <th className=\"proyeccion\">Proy Este</th>\r\n                    <th className=\"coordenada\">Norte</th>\r\n                    <th className=\"coordenada\">Este</th>\r\n                    <th className=\"altura\">Altura</th> {/* Nueva columna */}\r\n                  </tr>\r\n                </thead>\r\n                <tbody>\r\n                  {observaciones.map((obs, index) => {\r\n                    // Calcular la distancia vertical zenital\r\n                    const distanciaVertical = calcularDistanciaVerticalZenital(\r\n                      obs.gradosV,\r\n                      obs.minutosV,\r\n                      obs.segundosV,\r\n                      obs.distancia\r\n                    );\r\n\r\n                    // Calcular la altura ajustada sobre el piso\r\n                    const alturaCalculada = calcularAlturaObservacion(\r\n                      index === 0\r\n                        ? alturaInicial\r\n                        : observaciones[index - 1].alturaCalculada,\r\n                      distanciaVertical,\r\n                      obs.alturaInstrumental,\r\n                      obs.alturaPrisma\r\n                    );\r\n\r\n                    // Guardar la altura calculada en el objeto de observación\r\n                    observaciones[index].alturaCalculada = alturaCalculada;\r\n\r\n                    return (\r\n                      <tr key={index}>\r\n                        <td>{obs.id}</td> {/* Mostrar el ID */}\r\n                        <td>{obs.proyeccionNorte}m</td>\r\n                        <td>{obs.proyeccionEste}m</td>\r\n                        <td>{obs.nuevoNorte}</td>\r\n                        <td>{obs.nuevoEste}</td>\r\n                        <td>{alturaCalculada}</td>{\" \"}\r\n                        {/* Mostrar la altura calculada */}\r\n                      </tr>\r\n                    );\r\n                  })}\r\n                </tbody>\r\n              </table>\r\n              {/* Botón para borrar la última observación */}\r\n              <button type=\"button\" onClick={borrarUltimaObservacion}>\r\n                Borrar Última Observación\r\n              </button>\r\n              <>\r\n                {/* Resumen Angular de la Poligonal */}\r\n                <div className=\"resumen-angular\">\r\n                  <h3>Resumen Angular de la Poligonal</h3>\r\n                  <p>\r\n                    <strong>Suma Teórica:</strong>{\" \"}\r\n                    {`${sumaTeorica.grados}° ${sumaTeorica.minutos}' ${sumaTeorica.segundos}\"`}\r\n                  </p>\r\n                  <p>\r\n                    <strong>Suma Real:</strong>{\" \"}\r\n                    {`${sumaReal.grados}° ${sumaReal.minutos}' ${sumaReal.segundos}\"`}\r\n                  </p>\r\n                  <p>\r\n                    <strong>Error Angular:</strong>{\" \"}\r\n                    {`${errorAngular.grados}° ${errorAngular.minutos}' ${errorAngular.segundos}\"`}\r\n                  </p>\r\n                </div>\r\n\r\n                {/* Totales */}\r\n                <div className=\"totales\">\r\n                  <h3>Totales</h3>\r\n                  <p>\r\n                    <strong>Total Distancia:</strong>{\" \"}\r\n                    {totalDistancia.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Total Proyección Norte:</strong>{\" \"}\r\n                    {totalProyeccionNorte.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Total Proyección Este:</strong>{\" \"}\r\n                    {totalProyeccionEste.toFixed(4)} m\r\n                  </p>\r\n                  <p>\r\n                    <strong>Cierre Alturas:</strong> {cierreAlturas} m\r\n                  </p>\r\n                </div>\r\n\r\n                {/* Precisión de la Poligonal */}\r\n                <div className=\"precision-poligonal\">\r\n                  <h3>Precisión de la Poligonal</h3>\r\n                  <p>\r\n                    <strong>Precisión:</strong> {precisionPoligonal}\r\n                  </p>\r\n                </div>\r\n              </>\r\n            </>\r\n          )}\r\n          {/* Botón para compensar la poligonal */}\r\n          <button type=\"button\" onClick={compensarPoligonal}>\r\n            Compensar Poligonal\r\n          </button>\r\n          <h3>Observaciones Compensadas</h3>\r\n          {/* Primera tabla */}\r\n          <table border=\"1\">\r\n            <thead>\r\n              <tr>\r\n                <th>ID</th>\r\n                <th>Ángulo H Compensado</th>\r\n                <th>Proyección N Compensada</th>\r\n                <th>Proyección E Compensada</th>\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {observacionesCompensadas.map((obs, index) => (\r\n                <tr key={index}>\r\n                  <td>{obs.id}</td>\r\n                  <td>{obs.anguloHorizontalCompensado}</td>\r\n                  <td>{obs.proyeccionNorteCompensada}m</td>\r\n                  <td>{obs.proyeccionEsteCompensada}m</td>\r\n                </tr>\r\n              ))}\r\n            </tbody>\r\n          </table>\r\n          <br /> {/* Espacio entre las dos tablas */}\r\n          {/* Segunda tabla */}\r\n          <table border=\"1\">\r\n            <thead>\r\n              <tr>\r\n                <th>ID</th> {/* Agregamos la columna ID en la segunda tabla */}\r\n                <th>Norte Ajustado</th>\r\n                <th>Este Ajustado</th>\r\n                <th>Altura Compensada</th>\r\n              </tr>\r\n            </thead>\r\n            <tbody>\r\n              {observacionesCompensadas.map((obs, index) => {\r\n                // Recalcular las coordenadas ajustadas con las proyecciones compensadas\r\n                const { nuevoNorteAjustado, nuevoEsteAjustado } =\r\n                  recalcularCoordenadasAjustadas(\r\n                    index === 0\r\n                      ? norteInicial // Coordenada inicial para la primera observación\r\n                      : observacionesCompensadas[index - 1].nuevoNorteAjustado, // Coordenada anterior para las demás\r\n                    index === 0\r\n                      ? esteInicial\r\n                      : observacionesCompensadas[index - 1].nuevoEsteAjustado,\r\n                    obs.proyeccionNorteCompensada,\r\n                    obs.proyeccionEsteCompensada\r\n                  );\r\n\r\n                // Actualizamos las coordenadas ajustadas en el objeto de observación compensada\r\n                observacionesCompensadas[index].nuevoNorteAjustado =\r\n                  nuevoNorteAjustado;\r\n                observacionesCompensadas[index].nuevoEsteAjustado =\r\n                  nuevoEsteAjustado;\r\n\r\n                return (\r\n                  <tr key={index}>\r\n                    <td>{obs.id}</td> {/* Mostrar ID en la segunda tabla */}\r\n                    <td>{nuevoNorteAjustado}</td>\r\n                    <td>{nuevoEsteAjustado}</td>\r\n                    <td>\r\n                      {isNaN(parseFloat(obs.alturaCompensada))\r\n                        ? \"-\"\r\n                        : parseFloat(obs.alturaCompensada).toFixed(3)}\r\n                    </td>\r\n                  </tr>\r\n                );\r\n              })}\r\n            </tbody>\r\n          </table>\r\n          {/* Tabla de observaciones compensadas */}\r\n          {observacionesCompensadas.length > 0 && (\r\n            <>\r\n              {/* Añadir el gráfico aquí */}\r\n\r\n              <div className=\"app-container\">\r\n                <GraficoPoligonal\r\n                  observacionesCompensadas={observacionesCompensadas}\r\n                />\r\n              </div>\r\n            </>\r\n          )}\r\n        </>\r\n      )}\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default FormularioObservacion;\r\n","import React, { useState } from \"react\";\nimport FormularioObservacion from \"./components/FormularioObservacion\";\n\nimport \"./App.css\";\n\nfunction App() {\n  const [observaciones, setObservaciones] = useState([]);\n\n  const agregarObservacion = (observacion) => {\n    setObservaciones([...observaciones, observacion]);\n  };\n\n  return (\n    <div className=\"App\">\n      <h1>Cálculo de Poligonales</h1>\n      <FormularioObservacion agregarObservacion={agregarObservacion} />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}